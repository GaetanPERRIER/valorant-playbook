{
  "version": 3,
  "sources": ["../../../../@jridgewell/sourcemap-codec/src/sourcemap-codec.ts", "../../../../@unocss/core/dist/index.mjs", "../../../../magic-string/src/BitSet.js", "../../../../magic-string/src/Chunk.js", "../../../../magic-string/src/SourceMap.js", "../../../../magic-string/src/utils/guessIndent.js", "../../../../magic-string/src/utils/getRelativePath.js", "../../../../magic-string/src/utils/isObject.js", "../../../../magic-string/src/utils/getLocator.js", "../../../../magic-string/src/utils/Mappings.js", "../../../../magic-string/src/MagicString.js", "../../../../magic-string/src/Bundle.js", "../../../../@unocss/rule-utils/dist/index.mjs", "../../../../@unocss/preset-mini/dist/shared/preset-mini.CWuOZAHF.mjs"],
  "sourcesContent": ["export type SourceMapSegment =\n  | [number]\n  | [number, number, number, number]\n  | [number, number, number, number, number];\nexport type SourceMapLine = SourceMapSegment[];\nexport type SourceMapMappings = SourceMapLine[];\n\nconst comma = ','.charCodeAt(0);\nconst semicolon = ';'.charCodeAt(0);\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nconst intToChar = new Uint8Array(64); // 64 possible chars.\nconst charToInt = new Uint8Array(128); // z is 122 in ASCII\n\nfor (let i = 0; i < chars.length; i++) {\n  const c = chars.charCodeAt(i);\n  intToChar[i] = c;\n  charToInt[c] = i;\n}\n\n// Provide a fallback for older environments.\nconst td =\n  typeof TextDecoder !== 'undefined'\n    ? /* #__PURE__ */ new TextDecoder()\n    : typeof Buffer !== 'undefined'\n    ? {\n        decode(buf: Uint8Array) {\n          const out = Buffer.from(buf.buffer, buf.byteOffset, buf.byteLength);\n          return out.toString();\n        },\n      }\n    : {\n        decode(buf: Uint8Array) {\n          let out = '';\n          for (let i = 0; i < buf.length; i++) {\n            out += String.fromCharCode(buf[i]);\n          }\n          return out;\n        },\n      };\n\nexport function decode(mappings: string): SourceMapMappings {\n  const state: [number, number, number, number, number] = new Int32Array(5) as any;\n  const decoded: SourceMapMappings = [];\n\n  let index = 0;\n  do {\n    const semi = indexOf(mappings, index);\n    const line: SourceMapLine = [];\n    let sorted = true;\n    let lastCol = 0;\n    state[0] = 0;\n\n    for (let i = index; i < semi; i++) {\n      let seg: SourceMapSegment;\n\n      i = decodeInteger(mappings, i, state, 0); // genColumn\n      const col = state[0];\n      if (col < lastCol) sorted = false;\n      lastCol = col;\n\n      if (hasMoreVlq(mappings, i, semi)) {\n        i = decodeInteger(mappings, i, state, 1); // sourcesIndex\n        i = decodeInteger(mappings, i, state, 2); // sourceLine\n        i = decodeInteger(mappings, i, state, 3); // sourceColumn\n\n        if (hasMoreVlq(mappings, i, semi)) {\n          i = decodeInteger(mappings, i, state, 4); // namesIndex\n          seg = [col, state[1], state[2], state[3], state[4]];\n        } else {\n          seg = [col, state[1], state[2], state[3]];\n        }\n      } else {\n        seg = [col];\n      }\n\n      line.push(seg);\n    }\n\n    if (!sorted) sort(line);\n    decoded.push(line);\n    index = semi + 1;\n  } while (index <= mappings.length);\n\n  return decoded;\n}\n\nfunction indexOf(mappings: string, index: number): number {\n  const idx = mappings.indexOf(';', index);\n  return idx === -1 ? mappings.length : idx;\n}\n\nfunction decodeInteger(mappings: string, pos: number, state: SourceMapSegment, j: number): number {\n  let value = 0;\n  let shift = 0;\n  let integer = 0;\n\n  do {\n    const c = mappings.charCodeAt(pos++);\n    integer = charToInt[c];\n    value |= (integer & 31) << shift;\n    shift += 5;\n  } while (integer & 32);\n\n  const shouldNegate = value & 1;\n  value >>>= 1;\n\n  if (shouldNegate) {\n    value = -0x80000000 | -value;\n  }\n\n  state[j] += value;\n  return pos;\n}\n\nfunction hasMoreVlq(mappings: string, i: number, length: number): boolean {\n  if (i >= length) return false;\n  return mappings.charCodeAt(i) !== comma;\n}\n\nfunction sort(line: SourceMapSegment[]) {\n  line.sort(sortComparator);\n}\n\nfunction sortComparator(a: SourceMapSegment, b: SourceMapSegment): number {\n  return a[0] - b[0];\n}\n\nexport function encode(decoded: SourceMapMappings): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string;\nexport function encode(decoded: Readonly<SourceMapMappings>): string {\n  const state: [number, number, number, number, number] = new Int32Array(5) as any;\n  const bufLength = 1024 * 16;\n  const subLength = bufLength - 36;\n  const buf = new Uint8Array(bufLength);\n  const sub = buf.subarray(0, subLength);\n  let pos = 0;\n  let out = '';\n\n  for (let i = 0; i < decoded.length; i++) {\n    const line = decoded[i];\n    if (i > 0) {\n      if (pos === bufLength) {\n        out += td.decode(buf);\n        pos = 0;\n      }\n      buf[pos++] = semicolon;\n    }\n    if (line.length === 0) continue;\n\n    state[0] = 0;\n\n    for (let j = 0; j < line.length; j++) {\n      const segment = line[j];\n      // We can push up to 5 ints, each int can take at most 7 chars, and we\n      // may push a comma.\n      if (pos > subLength) {\n        out += td.decode(sub);\n        buf.copyWithin(0, subLength, pos);\n        pos -= subLength;\n      }\n      if (j > 0) buf[pos++] = comma;\n\n      pos = encodeInteger(buf, pos, state, segment, 0); // genColumn\n\n      if (segment.length === 1) continue;\n      pos = encodeInteger(buf, pos, state, segment, 1); // sourcesIndex\n      pos = encodeInteger(buf, pos, state, segment, 2); // sourceLine\n      pos = encodeInteger(buf, pos, state, segment, 3); // sourceColumn\n\n      if (segment.length === 4) continue;\n      pos = encodeInteger(buf, pos, state, segment, 4); // namesIndex\n    }\n  }\n\n  return out + td.decode(buf.subarray(0, pos));\n}\n\nfunction encodeInteger(\n  buf: Uint8Array,\n  pos: number,\n  state: SourceMapSegment,\n  segment: SourceMapSegment,\n  j: number,\n): number {\n  const next = segment[j];\n  let num = next - state[j];\n  state[j] = next;\n\n  num = num < 0 ? (-num << 1) | 1 : num << 1;\n  do {\n    let clamped = num & 0b011111;\n    num >>>= 5;\n    if (num > 0) clamped |= 0b100000;\n    buf[pos++] = intToChar[clamped];\n  } while (num > 0);\n\n  return pos;\n}\n", "function escapeRegExp(string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction escapeSelector(str) {\n  const length = str.length;\n  let index = -1;\n  let codeUnit;\n  let result = \"\";\n  const firstCodeUnit = str.charCodeAt(0);\n  while (++index < length) {\n    codeUnit = str.charCodeAt(index);\n    if (codeUnit === 0) {\n      result += \"\\uFFFD\";\n      continue;\n    }\n    if (codeUnit === 37) {\n      result += \"\\\\%\";\n      continue;\n    }\n    if (codeUnit === 44) {\n      result += \"\\\\,\";\n      continue;\n    }\n    if (\n      // If the character is in the range [\\1-\\1F] (U+0001 to U+001F) or is\n      // U+007F, […]\n      codeUnit >= 1 && codeUnit <= 31 || codeUnit === 127 || index === 0 && codeUnit >= 48 && codeUnit <= 57 || index === 1 && codeUnit >= 48 && codeUnit <= 57 && firstCodeUnit === 45\n    ) {\n      result += `\\\\${codeUnit.toString(16)} `;\n      continue;\n    }\n    if (\n      // If the character is the first character and is a `-` (U+002D), and\n      // there is no second character, […]\n      index === 0 && length === 1 && codeUnit === 45\n    ) {\n      result += `\\\\${str.charAt(index)}`;\n      continue;\n    }\n    if (codeUnit >= 128 || codeUnit === 45 || codeUnit === 95 || codeUnit >= 48 && codeUnit <= 57 || codeUnit >= 65 && codeUnit <= 90 || codeUnit >= 97 && codeUnit <= 122) {\n      result += str.charAt(index);\n      continue;\n    }\n    result += `\\\\${str.charAt(index)}`;\n  }\n  return result;\n}\nconst e = escapeSelector;\n\nfunction toArray(value = []) {\n  return Array.isArray(value) ? value : [value];\n}\nfunction uniq(value) {\n  return Array.from(new Set(value));\n}\nfunction uniqueBy(array, equalFn) {\n  return array.reduce((acc, cur) => {\n    const index = acc.findIndex((item) => equalFn(cur, item));\n    if (index === -1)\n      acc.push(cur);\n    return acc;\n  }, []);\n}\nfunction isString(s) {\n  return typeof s === \"string\";\n}\n\nfunction normalizeCSSEntries(obj) {\n  if (isString(obj))\n    return obj;\n  return (!Array.isArray(obj) ? Object.entries(obj) : obj).filter((i) => i[1] != null);\n}\nfunction normalizeCSSValues(obj) {\n  if (Array.isArray(obj)) {\n    if (obj.find((i) => !Array.isArray(i) || Array.isArray(i[0])))\n      return obj.map((i) => normalizeCSSEntries(i));\n    else\n      return [obj];\n  } else {\n    return [normalizeCSSEntries(obj)];\n  }\n}\nfunction clearIdenticalEntries(entry) {\n  return entry.filter(([k, v], idx) => {\n    if (k.startsWith(\"$$\"))\n      return false;\n    for (let i = idx - 1; i >= 0; i--) {\n      if (entry[i][0] === k && entry[i][1] === v)\n        return false;\n    }\n    return true;\n  });\n}\nfunction entriesToCss(arr) {\n  if (arr == null)\n    return \"\";\n  return clearIdenticalEntries(arr).map(([key, value]) => value != null ? `${key}:${value};` : void 0).filter(Boolean).join(\"\");\n}\nfunction isObject(item) {\n  return item && typeof item === \"object\" && !Array.isArray(item);\n}\nfunction mergeDeep(original, patch, mergeArray = false) {\n  const o = original;\n  const p = patch;\n  if (Array.isArray(p)) {\n    if (mergeArray && Array.isArray(p))\n      return [...o, ...p];\n    else\n      return [...p];\n  }\n  const output = { ...o };\n  if (isObject(o) && isObject(p)) {\n    Object.keys(p).forEach((key) => {\n      if (isObject(o[key]) && isObject(p[key]) || Array.isArray(o[key]) && Array.isArray(p[key]))\n        output[key] = mergeDeep(o[key], p[key], mergeArray);\n      else\n        Object.assign(output, { [key]: p[key] });\n    });\n  }\n  return output;\n}\nfunction clone(val) {\n  let k, out, tmp;\n  if (Array.isArray(val)) {\n    out = Array(k = val.length);\n    while (k--)\n      out[k] = (tmp = val[k]) && typeof tmp === \"object\" ? clone(tmp) : tmp;\n    return out;\n  }\n  if (Object.prototype.toString.call(val) === \"[object Object]\") {\n    out = {};\n    for (k in val) {\n      if (k === \"__proto__\") {\n        Object.defineProperty(out, k, {\n          value: clone(val[k]),\n          configurable: true,\n          enumerable: true,\n          writable: true\n        });\n      } else {\n        out[k] = (tmp = val[k]) && typeof tmp === \"object\" ? clone(tmp) : tmp;\n      }\n    }\n    return out;\n  }\n  return val;\n}\nfunction isStaticRule(rule) {\n  return isString(rule[0]);\n}\nfunction isStaticShortcut(sc) {\n  return isString(sc[0]);\n}\n\nconst attributifyRE = /^\\[(.+?)~?=\"(.*)\"\\]$/;\nconst cssIdRE = /\\.(css|postcss|sass|scss|less|stylus|styl)($|\\?)/;\nconst validateFilterRE = /[\\w\\u00A0-\\uFFFF-_:%-?]/;\nconst CONTROL_SHORTCUT_NO_MERGE = \"$$shortcut-no-merge\";\nfunction isAttributifySelector(selector) {\n  return selector.match(attributifyRE);\n}\nfunction isValidSelector(selector = \"\") {\n  return validateFilterRE.test(selector);\n}\nfunction normalizeVariant(variant) {\n  return typeof variant === \"function\" ? { match: variant } : variant;\n}\nfunction isRawUtil(util) {\n  return util.length === 3;\n}\nfunction notNull(value) {\n  return value != null;\n}\nfunction noop() {\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$2 = (obj, key, value) => {\n  __defNormalProp$2(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass TwoKeyMap {\n  constructor() {\n    __publicField$2(this, \"_map\", /* @__PURE__ */ new Map());\n  }\n  get(key1, key2) {\n    const m2 = this._map.get(key1);\n    if (m2)\n      return m2.get(key2);\n  }\n  getFallback(key1, key2, fallback) {\n    let m2 = this._map.get(key1);\n    if (!m2) {\n      m2 = /* @__PURE__ */ new Map();\n      this._map.set(key1, m2);\n    }\n    if (!m2.has(key2))\n      m2.set(key2, fallback);\n    return m2.get(key2);\n  }\n  set(key1, key2, value) {\n    let m2 = this._map.get(key1);\n    if (!m2) {\n      m2 = /* @__PURE__ */ new Map();\n      this._map.set(key1, m2);\n    }\n    m2.set(key2, value);\n    return this;\n  }\n  has(key1, key2) {\n    return this._map.get(key1)?.has(key2);\n  }\n  delete(key1, key2) {\n    return this._map.get(key1)?.delete(key2) || false;\n  }\n  deleteTop(key1) {\n    return this._map.delete(key1);\n  }\n  map(fn) {\n    return Array.from(this._map.entries()).flatMap(([k1, m2]) => Array.from(m2.entries()).map(([k2, v]) => {\n      return fn(v, k1, k2);\n    }));\n  }\n}\nclass BetterMap extends Map {\n  getFallback(key, fallback) {\n    const v = this.get(key);\n    if (v === void 0) {\n      this.set(key, fallback);\n      return fallback;\n    }\n    return v;\n  }\n  map(mapFn) {\n    const result = [];\n    this.forEach((v, k) => {\n      result.push(mapFn(v, k));\n    });\n    return result;\n  }\n  flatMap(mapFn) {\n    const result = [];\n    this.forEach((v, k) => {\n      result.push(...mapFn(v, k));\n    });\n    return result;\n  }\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField$1 = (obj, key, value) => {\n  __defNormalProp$1(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass CountableSet extends Set {\n  constructor(values) {\n    super(values);\n    __publicField$1(this, \"_map\");\n    this._map ?? (this._map = /* @__PURE__ */ new Map());\n  }\n  add(key) {\n    this._map ?? (this._map = /* @__PURE__ */ new Map());\n    this._map.set(key, (this._map.get(key) ?? 0) + 1);\n    return super.add(key);\n  }\n  delete(key) {\n    this._map.delete(key);\n    return super.delete(key);\n  }\n  clear() {\n    this._map.clear();\n    super.clear();\n  }\n  getCount(key) {\n    return this._map.get(key) ?? 0;\n  }\n  setCount(key, count) {\n    this._map.set(key, count);\n    return super.add(key);\n  }\n}\nfunction isCountableSet(value) {\n  return value instanceof CountableSet;\n}\n\nfunction withLayer(layer, rules) {\n  rules.forEach((r) => {\n    if (!r[2])\n      r[2] = { layer };\n    else\n      r[2].layer = layer;\n  });\n  return rules;\n}\n\nconst regexCache = {};\nfunction makeRegexClassGroup(separators = [\"-\", \":\"]) {\n  const key = separators.join(\"|\");\n  if (!regexCache[key])\n    regexCache[key] = new RegExp(`((?:[!@<~\\\\w+:_/-]|\\\\[&?>?:?\\\\S*\\\\])+?)(${key})\\\\(((?:[~!<>\\\\w\\\\s:/\\\\\\\\,%#.$?-]|\\\\[.*?\\\\])+?)\\\\)(?!\\\\s*?=>)`, \"gm\");\n  regexCache[key].lastIndex = 0;\n  return regexCache[key];\n}\nfunction parseVariantGroup(str, separators = [\"-\", \":\"], depth = 5) {\n  const regexClassGroup = makeRegexClassGroup(separators);\n  let hasChanged;\n  let content = str.toString();\n  const prefixes = /* @__PURE__ */ new Set();\n  const groupsByOffset = /* @__PURE__ */ new Map();\n  do {\n    hasChanged = false;\n    content = content.replace(\n      regexClassGroup,\n      (from, pre, sep, body, groupOffset) => {\n        if (!separators.includes(sep))\n          return from;\n        hasChanged = true;\n        prefixes.add(pre + sep);\n        const bodyOffset = groupOffset + pre.length + sep.length + 1;\n        const group = { length: from.length, items: [] };\n        groupsByOffset.set(groupOffset, group);\n        for (const itemMatch of [...body.matchAll(/\\S+/g)]) {\n          const itemOffset = bodyOffset + itemMatch.index;\n          let innerItems = groupsByOffset.get(itemOffset)?.items;\n          if (innerItems) {\n            groupsByOffset.delete(itemOffset);\n          } else {\n            innerItems = [{\n              offset: itemOffset,\n              length: itemMatch[0].length,\n              className: itemMatch[0]\n            }];\n          }\n          for (const item of innerItems) {\n            item.className = item.className === \"~\" ? pre : item.className.replace(/^(!?)(.*)/, `$1${pre}${sep}$2`);\n            group.items.push(item);\n          }\n        }\n        return \"$\".repeat(from.length);\n      }\n    );\n    depth -= 1;\n  } while (hasChanged && depth);\n  let expanded;\n  if (typeof str === \"string\") {\n    expanded = \"\";\n    let prevOffset = 0;\n    for (const [offset, group] of groupsByOffset) {\n      expanded += str.slice(prevOffset, offset);\n      expanded += group.items.map((item) => item.className).join(\" \");\n      prevOffset = offset + group.length;\n    }\n    expanded += str.slice(prevOffset);\n  } else {\n    expanded = str;\n    for (const [offset, group] of groupsByOffset) {\n      expanded.overwrite(\n        offset,\n        offset + group.length,\n        group.items.map((item) => item.className).join(\" \")\n      );\n    }\n  }\n  return {\n    prefixes: Array.from(prefixes),\n    hasChanged,\n    groupsByOffset,\n    // Computed lazily because MagicString's toString does a lot of work\n    get expanded() {\n      return expanded.toString();\n    }\n  };\n}\nfunction collapseVariantGroup(str, prefixes) {\n  const collection = /* @__PURE__ */ new Map();\n  const sortedPrefix = prefixes.sort((a, b) => b.length - a.length);\n  return str.split(/\\s+/g).map((part) => {\n    const prefix = sortedPrefix.find((prefix2) => part.startsWith(prefix2));\n    if (!prefix)\n      return part;\n    const body = part.slice(prefix.length);\n    if (collection.has(prefix)) {\n      collection.get(prefix).push(body);\n      return null;\n    } else {\n      const items = [body];\n      collection.set(prefix, items);\n      return {\n        prefix,\n        items\n      };\n    }\n  }).filter(notNull).map((i) => {\n    if (typeof i === \"string\")\n      return i;\n    return `${i.prefix}(${i.items.join(\" \")})`;\n  }).join(\" \");\n}\nfunction expandVariantGroup(str, separators = [\"-\", \":\"], depth = 5) {\n  const res = parseVariantGroup(str, separators, depth);\n  return typeof str === \"string\" ? res.expanded : str;\n}\n\nconst warned = /* @__PURE__ */ new Set();\nfunction warnOnce(msg) {\n  if (warned.has(msg))\n    return;\n  console.warn(\"[unocss]\", msg);\n  warned.add(msg);\n}\n\nconst defaultSplitRE = /[\\\\:]?[\\s'\"`;{}]+/g;\nconst splitWithVariantGroupRE = /([\\\\:]?[\\s\"'`;<>]|:\\(|\\)\"|\\)\\s)/g;\nfunction splitCode(code) {\n  return code.split(defaultSplitRE);\n}\nconst extractorSplit = {\n  name: \"@unocss/core/extractor-split\",\n  order: 0,\n  extract({ code }) {\n    return splitCode(code);\n  }\n};\n\nfunction createNanoEvents() {\n  return {\n    events: {},\n    emit(event, ...args) {\n      (this.events[event] || []).forEach((i) => i(...args));\n    },\n    on(event, cb) {\n      (this.events[event] = this.events[event] || []).push(cb);\n      return () => this.events[event] = (this.events[event] || []).filter((i) => i !== cb);\n    }\n  };\n}\n\nconst LAYER_DEFAULT = \"default\";\nconst LAYER_PREFLIGHTS = \"preflights\";\nconst LAYER_SHORTCUTS = \"shortcuts\";\nconst LAYER_IMPORTS = \"imports\";\nconst DEFAULT_LAYERS = {\n  [LAYER_IMPORTS]: -200,\n  [LAYER_PREFLIGHTS]: -100,\n  [LAYER_SHORTCUTS]: -10,\n  [LAYER_DEFAULT]: 0\n};\n\nfunction resolveShortcuts(shortcuts) {\n  return toArray(shortcuts).flatMap((s) => {\n    if (Array.isArray(s))\n      return [s];\n    return Object.entries(s);\n  });\n}\nconst __RESOLVED = \"_uno_resolved\";\nfunction resolvePreset(presetInput) {\n  let preset = typeof presetInput === \"function\" ? presetInput() : presetInput;\n  if (__RESOLVED in preset)\n    return preset;\n  preset = { ...preset };\n  Object.defineProperty(preset, __RESOLVED, {\n    value: true,\n    enumerable: false\n  });\n  const shortcuts = preset.shortcuts ? resolveShortcuts(preset.shortcuts) : void 0;\n  preset.shortcuts = shortcuts;\n  if (preset.prefix || preset.layer) {\n    const apply = (i) => {\n      if (!i[2])\n        i[2] = {};\n      const meta = i[2];\n      if (meta.prefix == null && preset.prefix)\n        meta.prefix = toArray(preset.prefix);\n      if (meta.layer == null && preset.layer)\n        meta.layer = preset.layer;\n    };\n    shortcuts?.forEach(apply);\n    preset.rules?.forEach(apply);\n  }\n  return preset;\n}\nfunction resolvePresets(preset) {\n  const root = resolvePreset(preset);\n  if (!root.presets)\n    return [root];\n  const nested = (root.presets || []).flatMap(toArray).flatMap(resolvePresets);\n  return [root, ...nested];\n}\nfunction resolveConfig(userConfig = {}, defaults = {}) {\n  const config = Object.assign({}, defaults, userConfig);\n  const rawPresets = uniqueBy((config.presets || []).flatMap(toArray).flatMap(resolvePresets), (a, b) => a.name === b.name);\n  const sortedPresets = [\n    ...rawPresets.filter((p) => p.enforce === \"pre\"),\n    ...rawPresets.filter((p) => !p.enforce),\n    ...rawPresets.filter((p) => p.enforce === \"post\")\n  ];\n  const sources = [\n    ...sortedPresets,\n    config\n  ];\n  const sourcesReversed = [...sources].reverse();\n  const layers = Object.assign({}, DEFAULT_LAYERS, ...sources.map((i) => i.layers));\n  function getMerged(key) {\n    return uniq(sources.flatMap((p) => toArray(p[key] || [])));\n  }\n  const extractors = getMerged(\"extractors\");\n  let extractorDefault = sourcesReversed.find((i) => i.extractorDefault !== void 0)?.extractorDefault;\n  if (extractorDefault === void 0)\n    extractorDefault = extractorSplit;\n  if (extractorDefault && !extractors.includes(extractorDefault))\n    extractors.unshift(extractorDefault);\n  extractors.sort((a, b) => (a.order || 0) - (b.order || 0));\n  const rules = getMerged(\"rules\");\n  const rulesStaticMap = {};\n  const rulesSize = rules.length;\n  const rulesDynamic = rules.map((rule, i) => {\n    if (isStaticRule(rule)) {\n      const prefixes = toArray(rule[2]?.prefix || \"\");\n      prefixes.forEach((prefix) => {\n        rulesStaticMap[prefix + rule[0]] = [i, rule[1], rule[2], rule];\n      });\n      return void 0;\n    }\n    return [i, ...rule];\n  }).filter(Boolean).reverse();\n  let theme = mergeThemes(sources.map((p) => p.theme));\n  const extendThemes = getMerged(\"extendTheme\");\n  for (const extendTheme of extendThemes)\n    theme = extendTheme(theme) || theme;\n  const autocomplete = {\n    templates: uniq(sources.flatMap((p) => toArray(p.autocomplete?.templates))),\n    extractors: sources.flatMap((p) => toArray(p.autocomplete?.extractors)).sort((a, b) => (a.order || 0) - (b.order || 0)),\n    shorthands: mergeAutocompleteShorthands(sources.map((p) => p.autocomplete?.shorthands || {}))\n  };\n  let separators = getMerged(\"separators\");\n  if (!separators.length)\n    separators = [\":\", \"-\"];\n  const resolved = {\n    mergeSelectors: true,\n    warn: true,\n    sortLayers: (layers2) => layers2,\n    ...config,\n    blocklist: getMerged(\"blocklist\"),\n    presets: sortedPresets,\n    envMode: config.envMode || \"build\",\n    shortcutsLayer: config.shortcutsLayer || \"shortcuts\",\n    layers,\n    theme,\n    rulesSize,\n    rulesDynamic,\n    rulesStaticMap,\n    preprocess: getMerged(\"preprocess\"),\n    postprocess: getMerged(\"postprocess\"),\n    preflights: getMerged(\"preflights\"),\n    autocomplete,\n    variants: getMerged(\"variants\").map(normalizeVariant).sort((a, b) => (a.order || 0) - (b.order || 0)),\n    shortcuts: resolveShortcuts(getMerged(\"shortcuts\")).reverse(),\n    extractors,\n    safelist: getMerged(\"safelist\"),\n    separators,\n    details: config.details ?? config.envMode === \"dev\"\n  };\n  for (const p of sources)\n    p?.configResolved?.(resolved);\n  return resolved;\n}\nfunction mergeConfigs(configs) {\n  const maybeArrays = [\"shortcuts\", \"preprocess\", \"postprocess\"];\n  const config = configs.map((config2) => Object.entries(config2).reduce((acc, [key, value]) => ({\n    ...acc,\n    [key]: maybeArrays.includes(key) ? toArray(value) : value\n  }), {})).reduce(({ theme: themeA, ...a }, { theme: themeB, ...b }) => {\n    const c = mergeDeep(a, b, true);\n    if (themeA || themeB)\n      c.theme = mergeThemes([themeA, themeB]);\n    return c;\n  }, {});\n  return config;\n}\nfunction mergeThemes(themes) {\n  return themes.map((theme) => theme ? clone(theme) : {}).reduce((a, b) => mergeDeep(a, b), {});\n}\nfunction mergeAutocompleteShorthands(shorthands) {\n  return shorthands.reduce((a, b) => {\n    const rs = {};\n    for (const key in b) {\n      const value = b[key];\n      if (Array.isArray(value))\n        rs[key] = `(${value.join(\"|\")})`;\n      else\n        rs[key] = value;\n    }\n    return {\n      ...a,\n      ...rs\n    };\n  }, {});\n}\nfunction definePreset(preset) {\n  return preset;\n}\n\nconst version = \"0.59.0\";\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass UnoGenerator {\n  constructor(userConfig = {}, defaults = {}) {\n    this.userConfig = userConfig;\n    this.defaults = defaults;\n    __publicField(this, \"version\", version);\n    __publicField(this, \"_cache\", /* @__PURE__ */ new Map());\n    __publicField(this, \"config\");\n    __publicField(this, \"blocked\", /* @__PURE__ */ new Set());\n    __publicField(this, \"parentOrders\", /* @__PURE__ */ new Map());\n    __publicField(this, \"events\", createNanoEvents());\n    this.config = resolveConfig(userConfig, defaults);\n    this.events.emit(\"config\", this.config);\n  }\n  setConfig(userConfig, defaults) {\n    if (!userConfig)\n      return;\n    if (defaults)\n      this.defaults = defaults;\n    this.userConfig = userConfig;\n    this.blocked.clear();\n    this.parentOrders.clear();\n    this._cache.clear();\n    this.config = resolveConfig(userConfig, this.defaults);\n    this.events.emit(\"config\", this.config);\n  }\n  async applyExtractors(code, id, extracted = /* @__PURE__ */ new Set()) {\n    const context = {\n      original: code,\n      code,\n      id,\n      extracted,\n      envMode: this.config.envMode\n    };\n    for (const extractor of this.config.extractors) {\n      const result = await extractor.extract?.(context);\n      if (!result)\n        continue;\n      if (isCountableSet(result) && isCountableSet(extracted)) {\n        for (const token of result)\n          extracted.setCount(token, extracted.getCount(token) + result.getCount(token));\n      } else {\n        for (const token of result)\n          extracted.add(token);\n      }\n    }\n    return extracted;\n  }\n  makeContext(raw, applied) {\n    const context = {\n      rawSelector: raw,\n      currentSelector: applied[1],\n      theme: this.config.theme,\n      generator: this,\n      variantHandlers: applied[2],\n      constructCSS: (...args) => this.constructCustomCSS(context, ...args),\n      variantMatch: applied\n    };\n    return context;\n  }\n  async parseToken(raw, alias) {\n    if (this.blocked.has(raw))\n      return;\n    const cacheKey = `${raw}${alias ? ` ${alias}` : \"\"}`;\n    if (this._cache.has(cacheKey))\n      return this._cache.get(cacheKey);\n    let current = raw;\n    for (const p of this.config.preprocess)\n      current = p(raw);\n    if (this.isBlocked(current)) {\n      this.blocked.add(raw);\n      this._cache.set(cacheKey, null);\n      return;\n    }\n    const applied = await this.matchVariants(raw, current);\n    if (!applied || this.isBlocked(applied[1])) {\n      this.blocked.add(raw);\n      this._cache.set(cacheKey, null);\n      return;\n    }\n    const context = this.makeContext(raw, [alias || applied[0], applied[1], applied[2], applied[3]]);\n    if (this.config.details)\n      context.variants = [...applied[3]];\n    const expanded = await this.expandShortcut(context.currentSelector, context);\n    const utils = expanded ? await this.stringifyShortcuts(context.variantMatch, context, expanded[0], expanded[1]) : (await this.parseUtil(context.variantMatch, context))?.map((i) => this.stringifyUtil(i, context)).filter(notNull);\n    if (utils?.length) {\n      this._cache.set(cacheKey, utils);\n      return utils;\n    }\n    this._cache.set(cacheKey, null);\n  }\n  async generate(input, options = {}) {\n    const {\n      id,\n      scope,\n      preflights = true,\n      safelist = true,\n      minify = false,\n      extendedInfo = false\n    } = options;\n    const outputCssLayers = this.config.outputToCssLayers;\n    const tokens = isString(input) ? await this.applyExtractors(\n      input,\n      id,\n      extendedInfo ? new CountableSet() : /* @__PURE__ */ new Set()\n    ) : Array.isArray(input) ? new Set(input) : input;\n    if (safelist) {\n      this.config.safelist.forEach((s) => {\n        if (!tokens.has(s))\n          tokens.add(s);\n      });\n    }\n    const nl = minify ? \"\" : \"\\n\";\n    const layerSet = /* @__PURE__ */ new Set([LAYER_DEFAULT]);\n    const matched = extendedInfo ? /* @__PURE__ */ new Map() : /* @__PURE__ */ new Set();\n    const sheet = /* @__PURE__ */ new Map();\n    let preflightsMap = {};\n    const tokenPromises = Array.from(tokens).map(async (raw) => {\n      if (matched.has(raw))\n        return;\n      const payload = await this.parseToken(raw);\n      if (payload == null)\n        return;\n      if (matched instanceof Map) {\n        matched.set(raw, {\n          data: payload,\n          count: isCountableSet(tokens) ? tokens.getCount(raw) : -1\n        });\n      } else {\n        matched.add(raw);\n      }\n      for (const item of payload) {\n        const parent = item[3] || \"\";\n        const layer = item[4]?.layer;\n        if (!sheet.has(parent))\n          sheet.set(parent, []);\n        sheet.get(parent).push(item);\n        if (layer)\n          layerSet.add(layer);\n      }\n    });\n    await Promise.all(tokenPromises);\n    await (async () => {\n      if (!preflights)\n        return;\n      const preflightContext = {\n        generator: this,\n        theme: this.config.theme\n      };\n      const preflightLayerSet = /* @__PURE__ */ new Set([]);\n      this.config.preflights.forEach(({ layer = LAYER_PREFLIGHTS }) => {\n        layerSet.add(layer);\n        preflightLayerSet.add(layer);\n      });\n      preflightsMap = Object.fromEntries(\n        await Promise.all(Array.from(preflightLayerSet).map(\n          async (layer) => {\n            const preflights2 = await Promise.all(\n              this.config.preflights.filter((i) => (i.layer || LAYER_PREFLIGHTS) === layer).map(async (i) => await i.getCSS(preflightContext))\n            );\n            const css = preflights2.filter(Boolean).join(nl);\n            return [layer, css];\n          }\n        ))\n      );\n    })();\n    const layers = this.config.sortLayers(Array.from(layerSet).sort((a, b) => (this.config.layers[a] ?? 0) - (this.config.layers[b] ?? 0) || a.localeCompare(b)));\n    const layerCache = {};\n    const getLayer = (layer = LAYER_DEFAULT) => {\n      if (layerCache[layer])\n        return layerCache[layer];\n      let css = Array.from(sheet).sort((a, b) => (this.parentOrders.get(a[0]) ?? 0) - (this.parentOrders.get(b[0]) ?? 0) || a[0]?.localeCompare(b[0] || \"\") || 0).map(([parent, items]) => {\n        const size = items.length;\n        const sorted = items.filter((i) => (i[4]?.layer || LAYER_DEFAULT) === layer).sort((a, b) => {\n          return a[0] - b[0] || (a[4]?.sort || 0) - (b[4]?.sort || 0) || a[5]?.currentSelector?.localeCompare(b[5]?.currentSelector ?? \"\") || a[1]?.localeCompare(b[1] || \"\") || a[2]?.localeCompare(b[2] || \"\") || 0;\n        }).map(([, selector, body, , meta, , variantNoMerge]) => {\n          const scopedSelector = selector ? applyScope(selector, scope) : selector;\n          return [\n            [[scopedSelector ?? \"\", meta?.sort ?? 0]],\n            body,\n            !!(variantNoMerge ?? meta?.noMerge)\n          ];\n        });\n        if (!sorted.length)\n          return void 0;\n        const rules = sorted.reverse().map(([selectorSortPair, body, noMerge], idx) => {\n          if (!noMerge && this.config.mergeSelectors) {\n            for (let i = idx + 1; i < size; i++) {\n              const current = sorted[i];\n              if (current && !current[2] && (selectorSortPair && current[0] || selectorSortPair == null && current[0] == null) && current[1] === body) {\n                if (selectorSortPair && current[0])\n                  current[0].push(...selectorSortPair);\n                return null;\n              }\n            }\n          }\n          const selectors = selectorSortPair ? uniq(selectorSortPair.sort((a, b) => a[1] - b[1] || a[0]?.localeCompare(b[0] || \"\") || 0).map((pair) => pair[0]).filter(Boolean)) : [];\n          return selectors.length ? `${selectors.join(`,${nl}`)}{${body}}` : body;\n        }).filter(Boolean).reverse().join(nl);\n        if (!parent)\n          return rules;\n        const parents = parent.split(\" $$ \");\n        return `${parents.join(\"{\")}{${nl}${rules}${nl}${\"}\".repeat(parents.length)}`;\n      }).filter(Boolean).join(nl);\n      if (preflights) {\n        css = [preflightsMap[layer], css].filter(Boolean).join(nl);\n      }\n      if (outputCssLayers && css) {\n        let cssLayer = typeof outputCssLayers === \"object\" ? outputCssLayers.cssLayerName?.(layer) : void 0;\n        if (cssLayer !== null) {\n          if (!cssLayer)\n            cssLayer = layer;\n          css = `@layer ${cssLayer}{${nl}${css}${nl}}`;\n        }\n      }\n      const layerMark = minify ? \"\" : `/* layer: ${layer} */${nl}`;\n      return layerCache[layer] = css ? layerMark + css : \"\";\n    };\n    const getLayers = (includes = layers, excludes) => {\n      return includes.filter((i) => !excludes?.includes(i)).map((i) => getLayer(i) || \"\").filter(Boolean).join(nl);\n    };\n    return {\n      get css() {\n        return getLayers();\n      },\n      layers,\n      matched,\n      getLayers,\n      getLayer\n    };\n  }\n  async matchVariants(raw, current) {\n    const variants = /* @__PURE__ */ new Set();\n    const handlers = [];\n    let processed = current || raw;\n    let applied = true;\n    const context = {\n      rawSelector: raw,\n      theme: this.config.theme,\n      generator: this\n    };\n    while (applied) {\n      applied = false;\n      for (const v of this.config.variants) {\n        if (!v.multiPass && variants.has(v))\n          continue;\n        let handler = await v.match(processed, context);\n        if (!handler)\n          continue;\n        if (isString(handler)) {\n          if (handler === processed)\n            continue;\n          handler = { matcher: handler };\n        }\n        processed = handler.matcher;\n        handlers.unshift(handler);\n        variants.add(v);\n        applied = true;\n        break;\n      }\n      if (!applied)\n        break;\n      if (handlers.length > 500)\n        throw new Error(`Too many variants applied to \"${raw}\"`);\n    }\n    return [raw, processed, handlers, variants];\n  }\n  applyVariants(parsed, variantHandlers = parsed[4], raw = parsed[1]) {\n    const handler = variantHandlers.slice().sort((a, b) => (a.order || 0) - (b.order || 0)).reduceRight(\n      (previous, v) => (input) => {\n        const entries = v.body?.(input.entries) || input.entries;\n        const parents = Array.isArray(v.parent) ? v.parent : [v.parent, void 0];\n        return (v.handle ?? defaultVariantHandler)({\n          ...input,\n          entries,\n          selector: v.selector?.(input.selector, entries) || input.selector,\n          parent: parents[0] || input.parent,\n          parentOrder: parents[1] || input.parentOrder,\n          layer: v.layer || input.layer,\n          sort: v.sort || input.sort\n        }, previous);\n      },\n      (input) => input\n    );\n    const variantContextResult = handler({\n      prefix: \"\",\n      selector: toEscapedSelector(raw),\n      pseudo: \"\",\n      entries: parsed[2]\n    });\n    const { parent, parentOrder } = variantContextResult;\n    if (parent != null && parentOrder != null)\n      this.parentOrders.set(parent, parentOrder);\n    const obj = {\n      selector: [\n        variantContextResult.prefix,\n        variantContextResult.selector,\n        variantContextResult.pseudo\n      ].join(\"\"),\n      entries: variantContextResult.entries,\n      parent,\n      layer: variantContextResult.layer,\n      sort: variantContextResult.sort,\n      noMerge: variantContextResult.noMerge\n    };\n    for (const p of this.config.postprocess)\n      p(obj);\n    return obj;\n  }\n  constructCustomCSS(context, body, overrideSelector) {\n    const normalizedBody = normalizeCSSEntries(body);\n    if (isString(normalizedBody))\n      return normalizedBody;\n    const { selector, entries, parent } = this.applyVariants([0, overrideSelector || context.rawSelector, normalizedBody, void 0, context.variantHandlers]);\n    const cssBody = `${selector}{${entriesToCss(entries)}}`;\n    if (parent)\n      return `${parent}{${cssBody}}`;\n    return cssBody;\n  }\n  async parseUtil(input, context, internal = false, shortcutPrefix) {\n    const [raw, processed, variantHandlers] = isString(input) ? await this.matchVariants(input) : input;\n    if (this.config.details)\n      context.rules = context.rules ?? [];\n    const staticMatch = this.config.rulesStaticMap[processed];\n    if (staticMatch) {\n      if (staticMatch[1] && (internal || !staticMatch[2]?.internal)) {\n        if (this.config.details)\n          context.rules.push(staticMatch[3]);\n        const index = staticMatch[0];\n        const entry = normalizeCSSEntries(staticMatch[1]);\n        const meta = staticMatch[2];\n        if (isString(entry))\n          return [[index, entry, meta]];\n        else\n          return [[index, raw, entry, meta, variantHandlers]];\n      }\n    }\n    context.variantHandlers = variantHandlers;\n    const { rulesDynamic } = this.config;\n    for (const [i, matcher, handler, meta] of rulesDynamic) {\n      if (meta?.internal && !internal)\n        continue;\n      let unprefixed = processed;\n      if (meta?.prefix) {\n        const prefixes = toArray(meta.prefix);\n        if (shortcutPrefix) {\n          const shortcutPrefixes = toArray(shortcutPrefix);\n          if (!prefixes.some((i2) => shortcutPrefixes.includes(i2)))\n            continue;\n        } else {\n          const prefix = prefixes.find((i2) => processed.startsWith(i2));\n          if (prefix == null)\n            continue;\n          unprefixed = processed.slice(prefix.length);\n        }\n      }\n      const match = unprefixed.match(matcher);\n      if (!match)\n        continue;\n      const result = await handler(match, context);\n      if (!result)\n        continue;\n      if (this.config.details)\n        context.rules.push([matcher, handler, meta]);\n      const entries = normalizeCSSValues(result).filter((i2) => i2.length);\n      if (entries.length) {\n        return entries.map((e2) => {\n          if (isString(e2))\n            return [i, e2, meta];\n          else\n            return [i, raw, e2, meta, variantHandlers];\n        });\n      }\n    }\n  }\n  stringifyUtil(parsed, context) {\n    if (!parsed)\n      return;\n    if (isRawUtil(parsed))\n      return [parsed[0], void 0, parsed[1], void 0, parsed[2], this.config.details ? context : void 0, void 0];\n    const { selector, entries, parent, layer: variantLayer, sort: variantSort, noMerge } = this.applyVariants(parsed);\n    const body = entriesToCss(entries);\n    if (!body)\n      return;\n    const { layer: metaLayer, sort: metaSort, ...meta } = parsed[3] ?? {};\n    const ruleMeta = {\n      ...meta,\n      layer: variantLayer ?? metaLayer,\n      sort: variantSort ?? metaSort\n    };\n    return [parsed[0], selector, body, parent, ruleMeta, this.config.details ? context : void 0, noMerge];\n  }\n  async expandShortcut(input, context, depth = 5) {\n    if (depth === 0)\n      return;\n    const recordShortcut = this.config.details ? (s) => {\n      context.shortcuts = context.shortcuts ?? [];\n      context.shortcuts.push(s);\n    } : noop;\n    let meta;\n    let result;\n    for (const s of this.config.shortcuts) {\n      let unprefixed = input;\n      if (s[2]?.prefix) {\n        const prefixes = toArray(s[2].prefix);\n        const prefix = prefixes.find((i) => input.startsWith(i));\n        if (prefix == null)\n          continue;\n        unprefixed = input.slice(prefix.length);\n      }\n      if (isStaticShortcut(s)) {\n        if (s[0] === unprefixed) {\n          meta = meta || s[2];\n          result = s[1];\n          recordShortcut(s);\n          break;\n        }\n      } else {\n        const match = unprefixed.match(s[0]);\n        if (match)\n          result = s[1](match, context);\n        if (result) {\n          meta = meta || s[2];\n          recordShortcut(s);\n          break;\n        }\n      }\n    }\n    if (isString(result))\n      result = expandVariantGroup(result.trim()).split(/\\s+/g);\n    if (!result) {\n      const [raw, inputWithoutVariant] = isString(input) ? await this.matchVariants(input) : input;\n      if (raw !== inputWithoutVariant) {\n        const expanded = await this.expandShortcut(inputWithoutVariant, context, depth - 1);\n        if (expanded)\n          result = expanded[0].map((item) => isString(item) ? raw.replace(inputWithoutVariant, item) : item);\n      }\n    }\n    if (!result)\n      return;\n    return [\n      (await Promise.all(result.map(async (r) => (isString(r) ? (await this.expandShortcut(r, context, depth - 1))?.[0] : void 0) || [r]))).flat(1).filter(Boolean),\n      meta\n    ];\n  }\n  async stringifyShortcuts(parent, context, expanded, meta = { layer: this.config.shortcutsLayer }) {\n    const layerMap = new BetterMap();\n    const parsed = (await Promise.all(uniq(expanded).map(async (i) => {\n      const result = isString(i) ? await this.parseUtil(i, context, true, meta.prefix) : [[Number.POSITIVE_INFINITY, \"{inline}\", normalizeCSSEntries(i), void 0, []]];\n      if (!result && this.config.warn)\n        warnOnce(`unmatched utility \"${i}\" in shortcut \"${parent[1]}\"`);\n      return result || [];\n    }))).flat(1).filter(Boolean).sort((a, b) => a[0] - b[0]);\n    const [raw, , parentVariants] = parent;\n    const rawStringifiedUtil = [];\n    for (const item of parsed) {\n      if (isRawUtil(item)) {\n        rawStringifiedUtil.push([item[0], void 0, item[1], void 0, item[2], context, void 0]);\n        continue;\n      }\n      const { selector, entries, parent: parent2, sort, noMerge, layer } = this.applyVariants(item, [...item[4], ...parentVariants], raw);\n      const selectorMap = layerMap.getFallback(layer ?? meta.layer, new TwoKeyMap());\n      const mapItem = selectorMap.getFallback(selector, parent2, [[], item[0]]);\n      mapItem[0].push([entries, !!(noMerge ?? item[3]?.noMerge), sort ?? 0]);\n    }\n    return rawStringifiedUtil.concat(layerMap.flatMap(\n      (selectorMap, layer) => selectorMap.map(([e2, index], selector, joinedParents) => {\n        const stringify = (flatten, noMerge, entrySortPair) => {\n          const maxSort = Math.max(...entrySortPair.map((e3) => e3[1]));\n          const entriesList = entrySortPair.map((e3) => e3[0]);\n          return (flatten ? [entriesList.flat(1)] : entriesList).map((entries) => {\n            const body = entriesToCss(entries);\n            if (body)\n              return [index, selector, body, joinedParents, { ...meta, noMerge, sort: maxSort, layer }, context, void 0];\n            return void 0;\n          });\n        };\n        const merges = [\n          [e2.filter(([, noMerge]) => noMerge).map(([entries, , sort]) => [entries, sort]), true],\n          [e2.filter(([, noMerge]) => !noMerge).map(([entries, , sort]) => [entries, sort]), false]\n        ];\n        return merges.map(([e3, noMerge]) => [\n          ...stringify(false, noMerge, e3.filter(([entries]) => entries.some((entry) => entry[0] === CONTROL_SHORTCUT_NO_MERGE))),\n          ...stringify(true, noMerge, e3.filter(([entries]) => entries.every((entry) => entry[0] !== CONTROL_SHORTCUT_NO_MERGE)))\n        ]);\n      }).flat(2).filter(Boolean)\n    ));\n  }\n  isBlocked(raw) {\n    return !raw || this.config.blocklist.some((e2) => typeof e2 === \"function\" ? e2(raw) : isString(e2) ? e2 === raw : e2.test(raw));\n  }\n}\nfunction createGenerator(config, defaults) {\n  return new UnoGenerator(config, defaults);\n}\nconst regexScopePlaceholder = /\\s\\$\\$\\s+/g;\nfunction hasScopePlaceholder(css) {\n  return regexScopePlaceholder.test(css);\n}\nfunction applyScope(css, scope) {\n  if (hasScopePlaceholder(css))\n    return css.replace(regexScopePlaceholder, scope ? ` ${scope} ` : \" \");\n  else\n    return scope ? `${scope} ${css}` : css;\n}\nconst attributifyRe = /^\\[(.+?)(~?=)\"(.*)\"\\]$/;\nfunction toEscapedSelector(raw) {\n  if (attributifyRe.test(raw))\n    return raw.replace(attributifyRe, (_, n, s, i) => `[${e(n)}${s}\"${e(i)}\"]`);\n  return `.${e(raw)}`;\n}\nfunction defaultVariantHandler(input, next) {\n  return next(input);\n}\n\nexport { BetterMap, CONTROL_SHORTCUT_NO_MERGE, CountableSet, TwoKeyMap, UnoGenerator, attributifyRE, clearIdenticalEntries, clone, collapseVariantGroup, createGenerator, cssIdRE, defaultSplitRE, definePreset, e, entriesToCss, escapeRegExp, escapeSelector, expandVariantGroup, extractorSplit as extractorDefault, extractorSplit, hasScopePlaceholder, isAttributifySelector, isCountableSet, isObject, isRawUtil, isStaticRule, isStaticShortcut, isString, isValidSelector, makeRegexClassGroup, mergeConfigs, mergeDeep, noop, normalizeCSSEntries, normalizeCSSValues, normalizeVariant, notNull, parseVariantGroup, regexScopePlaceholder, resolveConfig, resolvePreset, resolvePresets, resolveShortcuts, splitWithVariantGroupRE, toArray, toEscapedSelector, uniq, uniqueBy, validateFilterRE, warnOnce, withLayer };\n", "export default class BitSet {\n\tconstructor(arg) {\n\t\tthis.bits = arg instanceof BitSet ? arg.bits.slice() : [];\n\t}\n\n\tadd(n) {\n\t\tthis.bits[n >> 5] |= 1 << (n & 31);\n\t}\n\n\thas(n) {\n\t\treturn !!(this.bits[n >> 5] & (1 << (n & 31)));\n\t}\n}\n", "export default class Chunk {\n\tconstructor(start, end, content) {\n\t\tthis.start = start;\n\t\tthis.end = end;\n\t\tthis.original = content;\n\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\n\t\tthis.content = content;\n\t\tthis.storeName = false;\n\t\tthis.edited = false;\n\n\t\tif (DEBUG) {\n\t\t\t// we make these non-enumerable, for sanity while debugging\n\t\t\tObject.defineProperties(this, {\n\t\t\t\tprevious: { writable: true, value: null },\n\t\t\t\tnext: { writable: true, value: null },\n\t\t\t});\n\t\t} else {\n\t\t\tthis.previous = null;\n\t\t\tthis.next = null;\n\t\t}\n\t}\n\n\tappendLeft(content) {\n\t\tthis.outro += content;\n\t}\n\n\tappendRight(content) {\n\t\tthis.intro = this.intro + content;\n\t}\n\n\tclone() {\n\t\tconst chunk = new Chunk(this.start, this.end, this.original);\n\n\t\tchunk.intro = this.intro;\n\t\tchunk.outro = this.outro;\n\t\tchunk.content = this.content;\n\t\tchunk.storeName = this.storeName;\n\t\tchunk.edited = this.edited;\n\n\t\treturn chunk;\n\t}\n\n\tcontains(index) {\n\t\treturn this.start < index && index < this.end;\n\t}\n\n\teachNext(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.next;\n\t\t}\n\t}\n\n\teachPrevious(fn) {\n\t\tlet chunk = this;\n\t\twhile (chunk) {\n\t\t\tfn(chunk);\n\t\t\tchunk = chunk.previous;\n\t\t}\n\t}\n\n\tedit(content, storeName, contentOnly) {\n\t\tthis.content = content;\n\t\tif (!contentOnly) {\n\t\t\tthis.intro = '';\n\t\t\tthis.outro = '';\n\t\t}\n\t\tthis.storeName = storeName;\n\n\t\tthis.edited = true;\n\n\t\treturn this;\n\t}\n\n\tprependLeft(content) {\n\t\tthis.outro = content + this.outro;\n\t}\n\n\tprependRight(content) {\n\t\tthis.intro = content + this.intro;\n\t}\n\n\treset() {\n\t\tthis.intro = '';\n\t\tthis.outro = '';\n\t\tif (this.edited) {\n\t\t\tthis.content = this.original;\n\t\t\tthis.storeName = false;\n\t\t\tthis.edited = false;\n\t\t}\n\t}\n\n\tsplit(index) {\n\t\tconst sliceIndex = index - this.start;\n\n\t\tconst originalBefore = this.original.slice(0, sliceIndex);\n\t\tconst originalAfter = this.original.slice(sliceIndex);\n\n\t\tthis.original = originalBefore;\n\n\t\tconst newChunk = new Chunk(index, this.end, originalAfter);\n\t\tnewChunk.outro = this.outro;\n\t\tthis.outro = '';\n\n\t\tthis.end = index;\n\n\t\tif (this.edited) {\n\t\t\t// after split we should save the edit content record into the correct chunk\n\t\t\t// to make sure sourcemap correct\n\t\t\t// For example:\n\t\t\t// '  test'.trim()\n\t\t\t//     split   -> '  ' + 'test'\n\t\t\t//   ✔️ edit    -> '' + 'test'\n\t\t\t//   ✖️ edit    -> 'test' + '' \n\t\t\t// TODO is this block necessary?...\n\t\t\tnewChunk.edit('', false);\n\t\t\tthis.content = '';\n\t\t} else {\n\t\t\tthis.content = originalBefore;\n\t\t}\n\n\t\tnewChunk.next = this.next;\n\t\tif (newChunk.next) newChunk.next.previous = newChunk;\n\t\tnewChunk.previous = this;\n\t\tthis.next = newChunk;\n\n\t\treturn newChunk;\n\t}\n\n\ttoString() {\n\t\treturn this.intro + this.content + this.outro;\n\t}\n\n\ttrimEnd(rx) {\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tthis.split(this.start + trimmed.length).edit('', undefined, true);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tthis.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\tif (this.intro.length) return true;\n\t\t}\n\t}\n\n\ttrimStart(rx) {\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tconst trimmed = this.content.replace(rx, '');\n\n\t\tif (trimmed.length) {\n\t\t\tif (trimmed !== this.content) {\n\t\t\t\tconst newChunk = this.split(this.end - trimmed.length);\n\t\t\t\tif (this.edited) {\n\t\t\t\t\t// save the change, if it has been edited\n\t\t\t\t\tnewChunk.edit(trimmed, this.storeName, true);\n\t\t\t\t}\n\t\t\t\tthis.edit('', undefined, true);\n\t\t\t}\n\t\t\treturn true;\n\t\t} else {\n\t\t\tthis.edit('', undefined, true);\n\n\t\t\tthis.outro = this.outro.replace(rx, '');\n\t\t\tif (this.outro.length) return true;\n\t\t}\n\t}\n}\n", "import { encode } from '@jridgewell/sourcemap-codec';\n\nfunction getBtoa() {\n\tif (typeof globalThis !== 'undefined' && typeof globalThis.btoa === 'function') {\n\t\treturn (str) => globalThis.btoa(unescape(encodeURIComponent(str)));\n\t} else if (typeof Buffer === 'function') {\n\t\treturn (str) => Buffer.from(str, 'utf-8').toString('base64');\n\t} else {\n\t\treturn () => {\n\t\t\tthrow new Error('Unsupported environment: `window.btoa` or `Buffer` should be supported.');\n\t\t};\n\t}\n}\n\nconst btoa = /*#__PURE__*/ getBtoa();\n\nexport default class SourceMap {\n\tconstructor(properties) {\n\t\tthis.version = 3;\n\t\tthis.file = properties.file;\n\t\tthis.sources = properties.sources;\n\t\tthis.sourcesContent = properties.sourcesContent;\n\t\tthis.names = properties.names;\n\t\tthis.mappings = encode(properties.mappings);\n\t\tif (typeof properties.x_google_ignoreList !== 'undefined') {\n\t\t\tthis.x_google_ignoreList = properties.x_google_ignoreList;\n\t\t}\n\t}\n\n\ttoString() {\n\t\treturn JSON.stringify(this);\n\t}\n\n\ttoUrl() {\n\t\treturn 'data:application/json;charset=utf-8;base64,' + btoa(this.toString());\n\t}\n}\n", "export default function guessIndent(code) {\n\tconst lines = code.split('\\n');\n\n\tconst tabbed = lines.filter((line) => /^\\t+/.test(line));\n\tconst spaced = lines.filter((line) => /^ {2,}/.test(line));\n\n\tif (tabbed.length === 0 && spaced.length === 0) {\n\t\treturn null;\n\t}\n\n\t// More lines tabbed than spaced? Assume tabs, and\n\t// default to tabs in the case of a tie (or nothing\n\t// to go on)\n\tif (tabbed.length >= spaced.length) {\n\t\treturn '\\t';\n\t}\n\n\t// Otherwise, we need to guess the multiple\n\tconst min = spaced.reduce((previous, current) => {\n\t\tconst numSpaces = /^ +/.exec(current)[0].length;\n\t\treturn Math.min(numSpaces, previous);\n\t}, Infinity);\n\n\treturn new Array(min + 1).join(' ');\n}\n", "export default function getRelativePath(from, to) {\n\tconst fromParts = from.split(/[/\\\\]/);\n\tconst toParts = to.split(/[/\\\\]/);\n\n\tfromParts.pop(); // get dirname\n\n\twhile (fromParts[0] === toParts[0]) {\n\t\tfromParts.shift();\n\t\ttoParts.shift();\n\t}\n\n\tif (fromParts.length) {\n\t\tlet i = fromParts.length;\n\t\twhile (i--) fromParts[i] = '..';\n\t}\n\n\treturn fromParts.concat(toParts).join('/');\n}\n", "const toString = Object.prototype.toString;\n\nexport default function isObject(thing) {\n\treturn toString.call(thing) === '[object Object]';\n}\n", "export default function getLocator(source) {\n\tconst originalLines = source.split('\\n');\n\tconst lineOffsets = [];\n\n\tfor (let i = 0, pos = 0; i < originalLines.length; i++) {\n\t\tlineOffsets.push(pos);\n\t\tpos += originalLines[i].length + 1;\n\t}\n\n\treturn function locate(index) {\n\t\tlet i = 0;\n\t\tlet j = lineOffsets.length;\n\t\twhile (i < j) {\n\t\t\tconst m = (i + j) >> 1;\n\t\t\tif (index < lineOffsets[m]) {\n\t\t\t\tj = m;\n\t\t\t} else {\n\t\t\t\ti = m + 1;\n\t\t\t}\n\t\t}\n\t\tconst line = i - 1;\n\t\tconst column = index - lineOffsets[line];\n\t\treturn { line, column };\n\t};\n}\n", "const wordRegex = /\\w/;\n\nexport default class Mappings {\n\tconstructor(hires) {\n\t\tthis.hires = hires;\n\t\tthis.generatedCodeLine = 0;\n\t\tthis.generatedCodeColumn = 0;\n\t\tthis.raw = [];\n\t\tthis.rawSegments = this.raw[this.generatedCodeLine] = [];\n\t\tthis.pending = null;\n\t}\n\n\taddEdit(sourceIndex, content, loc, nameIndex) {\n\t\tif (content.length) {\n\t\t\tconst contentLengthMinusOne = content.length - 1;\n\t\t\tlet contentLineEnd = content.indexOf('\\n', 0);\n\t\t\tlet previousContentLineEnd = -1;\n\t\t\t// Loop through each line in the content and add a segment, but stop if the last line is empty,\n\t\t\t// else code afterwards would fill one line too many\n\t\t\twhile (contentLineEnd >= 0 && contentLengthMinusOne > contentLineEnd) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\t\tif (nameIndex >= 0) {\n\t\t\t\t\tsegment.push(nameIndex);\n\t\t\t\t}\n\t\t\t\tthis.rawSegments.push(segment);\n\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\n\t\t\t\tpreviousContentLineEnd = contentLineEnd;\n\t\t\t\tcontentLineEnd = content.indexOf('\\n', contentLineEnd + 1);\n\t\t\t}\n\n\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\t\t\tif (nameIndex >= 0) {\n\t\t\t\tsegment.push(nameIndex);\n\t\t\t}\n\t\t\tthis.rawSegments.push(segment);\n\n\t\t\tthis.advance(content.slice(previousContentLineEnd + 1));\n\t\t} else if (this.pending) {\n\t\t\tthis.rawSegments.push(this.pending);\n\t\t\tthis.advance(content);\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\taddUneditedChunk(sourceIndex, chunk, original, loc, sourcemapLocations) {\n\t\tlet originalCharIndex = chunk.start;\n\t\tlet first = true;\n\t\t// when iterating each char, check if it's in a word boundary\n\t\tlet charInHiresBoundary = false;\n\n\t\twhile (originalCharIndex < chunk.end) {\n\t\t\tif (this.hires || first || sourcemapLocations.has(originalCharIndex)) {\n\t\t\t\tconst segment = [this.generatedCodeColumn, sourceIndex, loc.line, loc.column];\n\n\t\t\t\tif (this.hires === 'boundary') {\n\t\t\t\t\t// in hires \"boundary\", group segments per word boundary than per char\n\t\t\t\t\tif (wordRegex.test(original[originalCharIndex])) {\n\t\t\t\t\t\t// for first char in the boundary found, start the boundary by pushing a segment\n\t\t\t\t\t\tif (!charInHiresBoundary) {\n\t\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\t\tcharInHiresBoundary = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// for non-word char, end the boundary by pushing a segment\n\t\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t\t\tcharInHiresBoundary = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.rawSegments.push(segment);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (original[originalCharIndex] === '\\n') {\n\t\t\t\tloc.line += 1;\n\t\t\t\tloc.column = 0;\n\t\t\t\tthis.generatedCodeLine += 1;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t\tthis.generatedCodeColumn = 0;\n\t\t\t\tfirst = true;\n\t\t\t} else {\n\t\t\t\tloc.column += 1;\n\t\t\t\tthis.generatedCodeColumn += 1;\n\t\t\t\tfirst = false;\n\t\t\t}\n\n\t\t\toriginalCharIndex += 1;\n\t\t}\n\n\t\tthis.pending = null;\n\t}\n\n\tadvance(str) {\n\t\tif (!str) return;\n\n\t\tconst lines = str.split('\\n');\n\n\t\tif (lines.length > 1) {\n\t\t\tfor (let i = 0; i < lines.length - 1; i++) {\n\t\t\t\tthis.generatedCodeLine++;\n\t\t\t\tthis.raw[this.generatedCodeLine] = this.rawSegments = [];\n\t\t\t}\n\t\t\tthis.generatedCodeColumn = 0;\n\t\t}\n\n\t\tthis.generatedCodeColumn += lines[lines.length - 1].length;\n\t}\n}\n", "import BitSet from './BitSet.js';\nimport Chunk from './Chunk.js';\nimport SourceMap from './SourceMap.js';\nimport guessIndent from './utils/guessIndent.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\nimport Stats from './utils/Stats.js';\n\nconst n = '\\n';\n\nconst warned = {\n\tinsertLeft: false,\n\tinsertRight: false,\n\tstoreName: false,\n};\n\nexport default class MagicString {\n\tconstructor(string, options = {}) {\n\t\tconst chunk = new Chunk(0, string.length, string);\n\n\t\tObject.defineProperties(this, {\n\t\t\toriginal: { writable: true, value: string },\n\t\t\toutro: { writable: true, value: '' },\n\t\t\tintro: { writable: true, value: '' },\n\t\t\tfirstChunk: { writable: true, value: chunk },\n\t\t\tlastChunk: { writable: true, value: chunk },\n\t\t\tlastSearchedChunk: { writable: true, value: chunk },\n\t\t\tbyStart: { writable: true, value: {} },\n\t\t\tbyEnd: { writable: true, value: {} },\n\t\t\tfilename: { writable: true, value: options.filename },\n\t\t\tindentExclusionRanges: { writable: true, value: options.indentExclusionRanges },\n\t\t\tsourcemapLocations: { writable: true, value: new BitSet() },\n\t\t\tstoredNames: { writable: true, value: {} },\n\t\t\tindentStr: { writable: true, value: undefined },\n\t\t\tignoreList: { writable: true, value: options.ignoreList },\n\t\t});\n\n\t\tif (DEBUG) {\n\t\t\tObject.defineProperty(this, 'stats', { value: new Stats() });\n\t\t}\n\n\t\tthis.byStart[0] = chunk;\n\t\tthis.byEnd[string.length] = chunk;\n\t}\n\n\taddSourcemapLocation(char) {\n\t\tthis.sourcemapLocations.add(char);\n\t}\n\n\tappend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.outro += content;\n\t\treturn this;\n\t}\n\n\tappendLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendLeft');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendLeft(content);\n\t\t} else {\n\t\t\tthis.intro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendLeft');\n\t\treturn this;\n\t}\n\n\tappendRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('appendRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.appendRight(content);\n\t\t} else {\n\t\t\tthis.outro += content;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('appendRight');\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst cloned = new MagicString(this.original, { filename: this.filename });\n\n\t\tlet originalChunk = this.firstChunk;\n\t\tlet clonedChunk = (cloned.firstChunk = cloned.lastSearchedChunk = originalChunk.clone());\n\n\t\twhile (originalChunk) {\n\t\t\tcloned.byStart[clonedChunk.start] = clonedChunk;\n\t\t\tcloned.byEnd[clonedChunk.end] = clonedChunk;\n\n\t\t\tconst nextOriginalChunk = originalChunk.next;\n\t\t\tconst nextClonedChunk = nextOriginalChunk && nextOriginalChunk.clone();\n\n\t\t\tif (nextClonedChunk) {\n\t\t\t\tclonedChunk.next = nextClonedChunk;\n\t\t\t\tnextClonedChunk.previous = clonedChunk;\n\n\t\t\t\tclonedChunk = nextClonedChunk;\n\t\t\t}\n\n\t\t\toriginalChunk = nextOriginalChunk;\n\t\t}\n\n\t\tcloned.lastChunk = clonedChunk;\n\n\t\tif (this.indentExclusionRanges) {\n\t\t\tcloned.indentExclusionRanges = this.indentExclusionRanges.slice();\n\t\t}\n\n\t\tcloned.sourcemapLocations = new BitSet(this.sourcemapLocations);\n\n\t\tcloned.intro = this.intro;\n\t\tcloned.outro = this.outro;\n\n\t\treturn cloned;\n\t}\n\n\tgenerateDecodedMap(options) {\n\t\toptions = options || {};\n\n\t\tconst sourceIndex = 0;\n\t\tconst names = Object.keys(this.storedNames);\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tconst locate = getLocator(this.original);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.firstChunk.eachNext((chunk) => {\n\t\t\tconst loc = locate(chunk.start);\n\n\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tmappings.addEdit(\n\t\t\t\t\tsourceIndex,\n\t\t\t\t\tchunk.content,\n\t\t\t\t\tloc,\n\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tmappings.addUneditedChunk(sourceIndex, chunk, this.original, loc, this.sourcemapLocations);\n\t\t\t}\n\n\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: [\n\t\t\t\toptions.source ? getRelativePath(options.file || '', options.source) : options.file || '',\n\t\t\t],\n\t\t\tsourcesContent: options.includeContent ? [this.original] : undefined,\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList: this.ignoreList ? [sourceIndex] : undefined,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\t_ensureindentStr() {\n\t\tif (this.indentStr === undefined) {\n\t\t\tthis.indentStr = guessIndent(this.original);\n\t\t}\n\t}\n\n\t_getRawIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr;\n\t}\n\n\tgetIndentString() {\n\t\tthis._ensureindentStr();\n\t\treturn this.indentStr === null ? '\\t' : this.indentStr;\n\t}\n\n\tindent(indentStr, options) {\n\t\tconst pattern = /^[^\\r\\n]/gm;\n\n\t\tif (isObject(indentStr)) {\n\t\t\toptions = indentStr;\n\t\t\tindentStr = undefined;\n\t\t}\n\n\t\tif (indentStr === undefined) {\n\t\t\tthis._ensureindentStr();\n\t\t\tindentStr = this.indentStr || '\\t';\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\toptions = options || {};\n\n\t\t// Process exclusion ranges\n\t\tconst isExcluded = {};\n\n\t\tif (options.exclude) {\n\t\t\tconst exclusions =\n\t\t\t\ttypeof options.exclude[0] === 'number' ? [options.exclude] : options.exclude;\n\t\t\texclusions.forEach((exclusion) => {\n\t\t\t\tfor (let i = exclusion[0]; i < exclusion[1]; i += 1) {\n\t\t\t\t\tisExcluded[i] = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tlet shouldIndentNextCharacter = options.indentStart !== false;\n\t\tconst replacer = (match) => {\n\t\t\tif (shouldIndentNextCharacter) return `${indentStr}${match}`;\n\t\t\tshouldIndentNextCharacter = true;\n\t\t\treturn match;\n\t\t};\n\n\t\tthis.intro = this.intro.replace(pattern, replacer);\n\n\t\tlet charIndex = 0;\n\t\tlet chunk = this.firstChunk;\n\n\t\twhile (chunk) {\n\t\t\tconst end = chunk.end;\n\n\t\t\tif (chunk.edited) {\n\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\tchunk.content = chunk.content.replace(pattern, replacer);\n\n\t\t\t\t\tif (chunk.content.length) {\n\t\t\t\t\t\tshouldIndentNextCharacter = chunk.content[chunk.content.length - 1] === '\\n';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcharIndex = chunk.start;\n\n\t\t\t\twhile (charIndex < end) {\n\t\t\t\t\tif (!isExcluded[charIndex]) {\n\t\t\t\t\t\tconst char = this.original[charIndex];\n\n\t\t\t\t\t\tif (char === '\\n') {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = true;\n\t\t\t\t\t\t} else if (char !== '\\r' && shouldIndentNextCharacter) {\n\t\t\t\t\t\t\tshouldIndentNextCharacter = false;\n\n\t\t\t\t\t\t\tif (charIndex === chunk.start) {\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthis._splitChunk(chunk, charIndex);\n\t\t\t\t\t\t\t\tchunk = chunk.next;\n\t\t\t\t\t\t\t\tchunk.prependRight(indentStr);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcharIndex += 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcharIndex = chunk.end;\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tthis.outro = this.outro.replace(pattern, replacer);\n\n\t\treturn this;\n\t}\n\n\tinsert() {\n\t\tthrow new Error(\n\t\t\t'magicString.insert(...) is deprecated. Use prependRight(...) or appendLeft(...)',\n\t\t);\n\t}\n\n\tinsertLeft(index, content) {\n\t\tif (!warned.insertLeft) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertLeft(...) is deprecated. Use magicString.appendLeft(...) instead',\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertLeft = true;\n\t\t}\n\n\t\treturn this.appendLeft(index, content);\n\t}\n\n\tinsertRight(index, content) {\n\t\tif (!warned.insertRight) {\n\t\t\tconsole.warn(\n\t\t\t\t'magicString.insertRight(...) is deprecated. Use magicString.prependRight(...) instead',\n\t\t\t); // eslint-disable-line no-console\n\t\t\twarned.insertRight = true;\n\t\t}\n\n\t\treturn this.prependRight(index, content);\n\t}\n\n\tmove(start, end, index) {\n\t\tif (index >= start && index <= end) throw new Error('Cannot move a selection inside itself');\n\n\t\tif (DEBUG) this.stats.time('move');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\t\tthis._split(index);\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tconst oldLeft = first.previous;\n\t\tconst oldRight = last.next;\n\n\t\tconst newRight = this.byStart[index];\n\t\tif (!newRight && last === this.lastChunk) return this;\n\t\tconst newLeft = newRight ? newRight.previous : this.lastChunk;\n\n\t\tif (oldLeft) oldLeft.next = oldRight;\n\t\tif (oldRight) oldRight.previous = oldLeft;\n\n\t\tif (newLeft) newLeft.next = first;\n\t\tif (newRight) newRight.previous = last;\n\n\t\tif (!first.previous) this.firstChunk = last.next;\n\t\tif (!last.next) {\n\t\t\tthis.lastChunk = first.previous;\n\t\t\tthis.lastChunk.next = null;\n\t\t}\n\n\t\tfirst.previous = newLeft;\n\t\tlast.next = newRight || null;\n\n\t\tif (!newLeft) this.firstChunk = first;\n\t\tif (!newRight) this.lastChunk = last;\n\n\t\tif (DEBUG) this.stats.timeEnd('move');\n\t\treturn this;\n\t}\n\n\toverwrite(start, end, content, options) {\n\t\toptions = options || {};\n\t\treturn this.update(start, end, content, { ...options, overwrite: !options.contentOnly });\n\t}\n\n\tupdate(start, end, content, options) {\n\t\tif (typeof content !== 'string') throw new TypeError('replacement content must be a string');\n\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (end > this.original.length) throw new Error('end is out of bounds');\n\t\tif (start === end)\n\t\t\tthrow new Error(\n\t\t\t\t'Cannot overwrite a zero-length range – use appendLeft or prependRight instead',\n\t\t\t);\n\n\t\tif (DEBUG) this.stats.time('overwrite');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tif (options === true) {\n\t\t\tif (!warned.storeName) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'The final argument to magicString.overwrite(...) should be an options object. See https://github.com/rich-harris/magic-string',\n\t\t\t\t); // eslint-disable-line no-console\n\t\t\t\twarned.storeName = true;\n\t\t\t}\n\n\t\t\toptions = { storeName: true };\n\t\t}\n\t\tconst storeName = options !== undefined ? options.storeName : false;\n\t\tconst overwrite = options !== undefined ? options.overwrite : false;\n\n\t\tif (storeName) {\n\t\t\tconst original = this.original.slice(start, end);\n\t\t\tObject.defineProperty(this.storedNames, original, {\n\t\t\t\twritable: true,\n\t\t\t\tvalue: true,\n\t\t\t\tenumerable: true,\n\t\t\t});\n\t\t}\n\n\t\tconst first = this.byStart[start];\n\t\tconst last = this.byEnd[end];\n\n\t\tif (first) {\n\t\t\tlet chunk = first;\n\t\t\twhile (chunk !== last) {\n\t\t\t\tif (chunk.next !== this.byStart[chunk.end]) {\n\t\t\t\t\tthrow new Error('Cannot overwrite across a split point');\n\t\t\t\t}\n\t\t\t\tchunk = chunk.next;\n\t\t\t\tchunk.edit('', false);\n\t\t\t}\n\n\t\t\tfirst.edit(content, storeName, !overwrite);\n\t\t} else {\n\t\t\t// must be inserting at the end\n\t\t\tconst newChunk = new Chunk(start, end, '').edit(content, storeName);\n\n\t\t\t// TODO last chunk in the array may not be the last chunk, if it's moved...\n\t\t\tlast.next = newChunk;\n\t\t\tnewChunk.previous = last;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('overwrite');\n\t\treturn this;\n\t}\n\n\tprepend(content) {\n\t\tif (typeof content !== 'string') throw new TypeError('outro content must be a string');\n\n\t\tthis.intro = content + this.intro;\n\t\treturn this;\n\t}\n\n\tprependLeft(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byEnd[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependLeft(content);\n\t\t} else {\n\t\t\tthis.intro = content + this.intro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tprependRight(index, content) {\n\t\tif (typeof content !== 'string') throw new TypeError('inserted content must be a string');\n\n\t\tif (DEBUG) this.stats.time('insertRight');\n\n\t\tthis._split(index);\n\n\t\tconst chunk = this.byStart[index];\n\n\t\tif (chunk) {\n\t\t\tchunk.prependRight(content);\n\t\t} else {\n\t\t\tthis.outro = content + this.outro;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('insertRight');\n\t\treturn this;\n\t}\n\n\tremove(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('remove');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.intro = '';\n\t\t\tchunk.outro = '';\n\t\t\tchunk.edit('');\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('remove');\n\t\treturn this;\n\t}\n\n\treset(start, end) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tif (start === end) return this;\n\n\t\tif (start < 0 || end > this.original.length) throw new Error('Character is out of bounds');\n\t\tif (start > end) throw new Error('end must be greater than start');\n\n\t\tif (DEBUG) this.stats.time('reset');\n\n\t\tthis._split(start);\n\t\tthis._split(end);\n\n\t\tlet chunk = this.byStart[start];\n\n\t\twhile (chunk) {\n\t\t\tchunk.reset();\n\n\t\t\tchunk = end > chunk.end ? this.byStart[chunk.end] : null;\n\t\t}\n\n\t\tif (DEBUG) this.stats.timeEnd('reset');\n\t\treturn this;\n\t}\n\n\tlastChar() {\n\t\tif (this.outro.length) return this.outro[this.outro.length - 1];\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length) return chunk.outro[chunk.outro.length - 1];\n\t\t\tif (chunk.content.length) return chunk.content[chunk.content.length - 1];\n\t\t\tif (chunk.intro.length) return chunk.intro[chunk.intro.length - 1];\n\t\t} while ((chunk = chunk.previous));\n\t\tif (this.intro.length) return this.intro[this.intro.length - 1];\n\t\treturn '';\n\t}\n\n\tlastLine() {\n\t\tlet lineIndex = this.outro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.outro.substr(lineIndex + 1);\n\t\tlet lineStr = this.outro;\n\t\tlet chunk = this.lastChunk;\n\t\tdo {\n\t\t\tif (chunk.outro.length > 0) {\n\t\t\t\tlineIndex = chunk.outro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.outro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.outro + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.content.length > 0) {\n\t\t\t\tlineIndex = chunk.content.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.content.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.content + lineStr;\n\t\t\t}\n\n\t\t\tif (chunk.intro.length > 0) {\n\t\t\t\tlineIndex = chunk.intro.lastIndexOf(n);\n\t\t\t\tif (lineIndex !== -1) return chunk.intro.substr(lineIndex + 1) + lineStr;\n\t\t\t\tlineStr = chunk.intro + lineStr;\n\t\t\t}\n\t\t} while ((chunk = chunk.previous));\n\t\tlineIndex = this.intro.lastIndexOf(n);\n\t\tif (lineIndex !== -1) return this.intro.substr(lineIndex + 1) + lineStr;\n\t\treturn this.intro + lineStr;\n\t}\n\n\tslice(start = 0, end = this.original.length) {\n\t\twhile (start < 0) start += this.original.length;\n\t\twhile (end < 0) end += this.original.length;\n\n\t\tlet result = '';\n\n\t\t// find start chunk\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk && (chunk.start > start || chunk.end <= start)) {\n\t\t\t// found end chunk before start\n\t\t\tif (chunk.start < end && chunk.end >= end) {\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\tif (chunk && chunk.edited && chunk.start !== start)\n\t\t\tthrow new Error(`Cannot use replaced character ${start} as slice start anchor.`);\n\n\t\tconst startChunk = chunk;\n\t\twhile (chunk) {\n\t\t\tif (chunk.intro && (startChunk !== chunk || chunk.start === start)) {\n\t\t\t\tresult += chunk.intro;\n\t\t\t}\n\n\t\t\tconst containsEnd = chunk.start < end && chunk.end >= end;\n\t\t\tif (containsEnd && chunk.edited && chunk.end !== end)\n\t\t\t\tthrow new Error(`Cannot use replaced character ${end} as slice end anchor.`);\n\n\t\t\tconst sliceStart = startChunk === chunk ? start - chunk.start : 0;\n\t\t\tconst sliceEnd = containsEnd ? chunk.content.length + end - chunk.end : chunk.content.length;\n\n\t\t\tresult += chunk.content.slice(sliceStart, sliceEnd);\n\n\t\t\tif (chunk.outro && (!containsEnd || chunk.end === end)) {\n\t\t\t\tresult += chunk.outro;\n\t\t\t}\n\n\t\t\tif (containsEnd) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t// TODO deprecate this? not really very useful\n\tsnip(start, end) {\n\t\tconst clone = this.clone();\n\t\tclone.remove(0, start);\n\t\tclone.remove(end, clone.original.length);\n\n\t\treturn clone;\n\t}\n\n\t_split(index) {\n\t\tif (this.byStart[index] || this.byEnd[index]) return;\n\n\t\tif (DEBUG) this.stats.time('_split');\n\n\t\tlet chunk = this.lastSearchedChunk;\n\t\tconst searchForward = index > chunk.end;\n\n\t\twhile (chunk) {\n\t\t\tif (chunk.contains(index)) return this._splitChunk(chunk, index);\n\n\t\t\tchunk = searchForward ? this.byStart[chunk.end] : this.byEnd[chunk.start];\n\t\t}\n\t}\n\n\t_splitChunk(chunk, index) {\n\t\tif (chunk.edited && chunk.content.length) {\n\t\t\t// zero-length edited chunks are a special case (overlapping replacements)\n\t\t\tconst loc = getLocator(this.original)(index);\n\t\t\tthrow new Error(\n\t\t\t\t`Cannot split a chunk that has already been edited (${loc.line}:${loc.column} – \"${chunk.original}\")`,\n\t\t\t);\n\t\t}\n\n\t\tconst newChunk = chunk.split(index);\n\n\t\tthis.byEnd[index] = chunk;\n\t\tthis.byStart[index] = newChunk;\n\t\tthis.byEnd[newChunk.end] = newChunk;\n\n\t\tif (chunk === this.lastChunk) this.lastChunk = newChunk;\n\n\t\tthis.lastSearchedChunk = chunk;\n\t\tif (DEBUG) this.stats.timeEnd('_split');\n\t\treturn true;\n\t}\n\n\ttoString() {\n\t\tlet str = this.intro;\n\n\t\tlet chunk = this.firstChunk;\n\t\twhile (chunk) {\n\t\t\tstr += chunk.toString();\n\t\t\tchunk = chunk.next;\n\t\t}\n\n\t\treturn str + this.outro;\n\t}\n\n\tisEmpty() {\n\t\tlet chunk = this.firstChunk;\n\t\tdo {\n\t\t\tif (\n\t\t\t\t(chunk.intro.length && chunk.intro.trim()) ||\n\t\t\t\t(chunk.content.length && chunk.content.trim()) ||\n\t\t\t\t(chunk.outro.length && chunk.outro.trim())\n\t\t\t)\n\t\t\t\treturn false;\n\t\t} while ((chunk = chunk.next));\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\tlet chunk = this.firstChunk;\n\t\tlet length = 0;\n\t\tdo {\n\t\t\tlength += chunk.intro.length + chunk.content.length + chunk.outro.length;\n\t\t} while ((chunk = chunk.next));\n\t\treturn length;\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimEndAborted(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tthis.outro = this.outro.replace(rx, '');\n\t\tif (this.outro.length) return true;\n\n\t\tlet chunk = this.lastChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimEnd(rx);\n\n\t\t\t// if chunk was trimmed, we have a new lastChunk\n\t\t\tif (chunk.end !== end) {\n\t\t\t\tif (this.lastChunk === chunk) {\n\t\t\t\t\tthis.lastChunk = chunk.next;\n\t\t\t\t}\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.previous;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimEnd(charType) {\n\t\tthis.trimEndAborted(charType);\n\t\treturn this;\n\t}\n\ttrimStartAborted(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\n\t\tthis.intro = this.intro.replace(rx, '');\n\t\tif (this.intro.length) return true;\n\n\t\tlet chunk = this.firstChunk;\n\n\t\tdo {\n\t\t\tconst end = chunk.end;\n\t\t\tconst aborted = chunk.trimStart(rx);\n\n\t\t\tif (chunk.end !== end) {\n\t\t\t\t// special case...\n\t\t\t\tif (chunk === this.lastChunk) this.lastChunk = chunk.next;\n\n\t\t\t\tthis.byEnd[chunk.end] = chunk;\n\t\t\t\tthis.byStart[chunk.next.start] = chunk.next;\n\t\t\t\tthis.byEnd[chunk.next.end] = chunk.next;\n\t\t\t}\n\n\t\t\tif (aborted) return true;\n\t\t\tchunk = chunk.next;\n\t\t} while (chunk);\n\n\t\treturn false;\n\t}\n\n\ttrimStart(charType) {\n\t\tthis.trimStartAborted(charType);\n\t\treturn this;\n\t}\n\n\thasChanged() {\n\t\treturn this.original !== this.toString();\n\t}\n\n\t_replaceRegexp(searchValue, replacement) {\n\t\tfunction getReplacement(match, str) {\n\t\t\tif (typeof replacement === 'string') {\n\t\t\t\treturn replacement.replace(/\\$(\\$|&|\\d+)/g, (_, i) => {\n\t\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/replace#specifying_a_string_as_a_parameter\n\t\t\t\t\tif (i === '$') return '$';\n\t\t\t\t\tif (i === '&') return match[0];\n\t\t\t\t\tconst num = +i;\n\t\t\t\t\tif (num < match.length) return match[+i];\n\t\t\t\t\treturn `$${i}`;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn replacement(...match, match.index, str, match.groups);\n\t\t\t}\n\t\t}\n\t\tfunction matchAll(re, str) {\n\t\t\tlet match;\n\t\t\tconst matches = [];\n\t\t\twhile ((match = re.exec(str))) {\n\t\t\t\tmatches.push(match);\n\t\t\t}\n\t\t\treturn matches;\n\t\t}\n\t\tif (searchValue.global) {\n\t\t\tconst matches = matchAll(searchValue, this.original);\n\t\t\tmatches.forEach((match) => {\n\t\t\t\tif (match.index != null) {\n\t\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\t\treplacement\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tconst match = this.original.match(searchValue);\n\t\t\tif (match && match.index != null) {\n\t\t\t\tconst replacement = getReplacement(match, this.original);\n\t\t\t\tif (replacement !== match[0]) {\n\t\t\t\t\tthis.overwrite(\n\t\t\t\t\t\tmatch.index,\n\t\t\t\t\t\tmatch.index + match[0].length,\n\t\t\t\t\t\treplacement\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t_replaceString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst index = original.indexOf(string);\n\n\t\tif (index !== -1) {\n\t\t\tthis.overwrite(index, index + string.length, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplace(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceString(searchValue, replacement);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n\n\t_replaceAllString(string, replacement) {\n\t\tconst { original } = this;\n\t\tconst stringLength = string.length;\n\t\tfor (\n\t\t\tlet index = original.indexOf(string);\n\t\t\tindex !== -1;\n\t\t\tindex = original.indexOf(string, index + stringLength)\n\t\t) {\n\t\t\tconst previous = original.slice(index, index + stringLength);\n\t\t\tif (previous !== replacement)\n\t\t\t\tthis.overwrite(index, index + stringLength, replacement);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\treplaceAll(searchValue, replacement) {\n\t\tif (typeof searchValue === 'string') {\n\t\t\treturn this._replaceAllString(searchValue, replacement);\n\t\t}\n\n\t\tif (!searchValue.global) {\n\t\t\tthrow new TypeError(\n\t\t\t\t'MagicString.prototype.replaceAll called with a non-global RegExp argument',\n\t\t\t);\n\t\t}\n\n\t\treturn this._replaceRegexp(searchValue, replacement);\n\t}\n}\n", "import MagicString from './MagicString.js';\nimport SourceMap from './SourceMap.js';\nimport getRelativePath from './utils/getRelativePath.js';\nimport isObject from './utils/isObject.js';\nimport getLocator from './utils/getLocator.js';\nimport Mappings from './utils/Mappings.js';\n\nconst hasOwnProp = Object.prototype.hasOwnProperty;\n\nexport default class Bundle {\n\tconstructor(options = {}) {\n\t\tthis.intro = options.intro || '';\n\t\tthis.separator = options.separator !== undefined ? options.separator : '\\n';\n\t\tthis.sources = [];\n\t\tthis.uniqueSources = [];\n\t\tthis.uniqueSourceIndexByFilename = {};\n\t}\n\n\taddSource(source) {\n\t\tif (source instanceof MagicString) {\n\t\t\treturn this.addSource({\n\t\t\t\tcontent: source,\n\t\t\t\tfilename: source.filename,\n\t\t\t\tseparator: this.separator,\n\t\t\t});\n\t\t}\n\n\t\tif (!isObject(source) || !source.content) {\n\t\t\tthrow new Error(\n\t\t\t\t'bundle.addSource() takes an object with a `content` property, which should be an instance of MagicString, and an optional `filename`',\n\t\t\t);\n\t\t}\n\n\t\t['filename', 'ignoreList', 'indentExclusionRanges', 'separator'].forEach((option) => {\n\t\t\tif (!hasOwnProp.call(source, option)) source[option] = source.content[option];\n\t\t});\n\n\t\tif (source.separator === undefined) {\n\t\t\t// TODO there's a bunch of this sort of thing, needs cleaning up\n\t\t\tsource.separator = this.separator;\n\t\t}\n\n\t\tif (source.filename) {\n\t\t\tif (!hasOwnProp.call(this.uniqueSourceIndexByFilename, source.filename)) {\n\t\t\t\tthis.uniqueSourceIndexByFilename[source.filename] = this.uniqueSources.length;\n\t\t\t\tthis.uniqueSources.push({ filename: source.filename, content: source.content.original });\n\t\t\t} else {\n\t\t\t\tconst uniqueSource = this.uniqueSources[this.uniqueSourceIndexByFilename[source.filename]];\n\t\t\t\tif (source.content.original !== uniqueSource.content) {\n\t\t\t\t\tthrow new Error(`Illegal source: same filename (${source.filename}), different contents`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.sources.push(source);\n\t\treturn this;\n\t}\n\n\tappend(str, options) {\n\t\tthis.addSource({\n\t\t\tcontent: new MagicString(str),\n\t\t\tseparator: (options && options.separator) || '',\n\t\t});\n\n\t\treturn this;\n\t}\n\n\tclone() {\n\t\tconst bundle = new Bundle({\n\t\t\tintro: this.intro,\n\t\t\tseparator: this.separator,\n\t\t});\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tbundle.addSource({\n\t\t\t\tfilename: source.filename,\n\t\t\t\tcontent: source.content.clone(),\n\t\t\t\tseparator: source.separator,\n\t\t\t});\n\t\t});\n\n\t\treturn bundle;\n\t}\n\n\tgenerateDecodedMap(options = {}) {\n\t\tconst names = [];\n\t\tlet x_google_ignoreList = undefined;\n\t\tthis.sources.forEach((source) => {\n\t\t\tObject.keys(source.content.storedNames).forEach((name) => {\n\t\t\t\tif (!~names.indexOf(name)) names.push(name);\n\t\t\t});\n\t\t});\n\n\t\tconst mappings = new Mappings(options.hires);\n\n\t\tif (this.intro) {\n\t\t\tmappings.advance(this.intro);\n\t\t}\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tif (i > 0) {\n\t\t\t\tmappings.advance(this.separator);\n\t\t\t}\n\n\t\t\tconst sourceIndex = source.filename ? this.uniqueSourceIndexByFilename[source.filename] : -1;\n\t\t\tconst magicString = source.content;\n\t\t\tconst locate = getLocator(magicString.original);\n\n\t\t\tif (magicString.intro) {\n\t\t\t\tmappings.advance(magicString.intro);\n\t\t\t}\n\n\t\t\tmagicString.firstChunk.eachNext((chunk) => {\n\t\t\t\tconst loc = locate(chunk.start);\n\n\t\t\t\tif (chunk.intro.length) mappings.advance(chunk.intro);\n\n\t\t\t\tif (source.filename) {\n\t\t\t\t\tif (chunk.edited) {\n\t\t\t\t\t\tmappings.addEdit(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk.content,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tchunk.storeName ? names.indexOf(chunk.original) : -1,\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmappings.addUneditedChunk(\n\t\t\t\t\t\t\tsourceIndex,\n\t\t\t\t\t\t\tchunk,\n\t\t\t\t\t\t\tmagicString.original,\n\t\t\t\t\t\t\tloc,\n\t\t\t\t\t\t\tmagicString.sourcemapLocations,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmappings.advance(chunk.content);\n\t\t\t\t}\n\n\t\t\t\tif (chunk.outro.length) mappings.advance(chunk.outro);\n\t\t\t});\n\n\t\t\tif (magicString.outro) {\n\t\t\t\tmappings.advance(magicString.outro);\n\t\t\t}\n\n\t\t\tif (source.ignoreList && sourceIndex !== -1) {\n\t\t\t\tif (x_google_ignoreList === undefined) {\n\t\t\t\t\tx_google_ignoreList = [];\n\t\t\t\t}\n\t\t\t\tx_google_ignoreList.push(sourceIndex);\n\t\t\t}\n\t\t});\n\n\t\treturn {\n\t\t\tfile: options.file ? options.file.split(/[/\\\\]/).pop() : undefined,\n\t\t\tsources: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.file ? getRelativePath(options.file, source.filename) : source.filename;\n\t\t\t}),\n\t\t\tsourcesContent: this.uniqueSources.map((source) => {\n\t\t\t\treturn options.includeContent ? source.content : null;\n\t\t\t}),\n\t\t\tnames,\n\t\t\tmappings: mappings.raw,\n\t\t\tx_google_ignoreList,\n\t\t};\n\t}\n\n\tgenerateMap(options) {\n\t\treturn new SourceMap(this.generateDecodedMap(options));\n\t}\n\n\tgetIndentString() {\n\t\tconst indentStringCounts = {};\n\n\t\tthis.sources.forEach((source) => {\n\t\t\tconst indentStr = source.content._getRawIndentString();\n\n\t\t\tif (indentStr === null) return;\n\n\t\t\tif (!indentStringCounts[indentStr]) indentStringCounts[indentStr] = 0;\n\t\t\tindentStringCounts[indentStr] += 1;\n\t\t});\n\n\t\treturn (\n\t\t\tObject.keys(indentStringCounts).sort((a, b) => {\n\t\t\t\treturn indentStringCounts[a] - indentStringCounts[b];\n\t\t\t})[0] || '\\t'\n\t\t);\n\t}\n\n\tindent(indentStr) {\n\t\tif (!arguments.length) {\n\t\t\tindentStr = this.getIndentString();\n\t\t}\n\n\t\tif (indentStr === '') return this; // noop\n\n\t\tlet trailingNewline = !this.intro || this.intro.slice(-1) === '\\n';\n\n\t\tthis.sources.forEach((source, i) => {\n\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\tconst indentStart = trailingNewline || (i > 0 && /\\r?\\n$/.test(separator));\n\n\t\t\tsource.content.indent(indentStr, {\n\t\t\t\texclude: source.indentExclusionRanges,\n\t\t\t\tindentStart, //: trailingNewline || /\\r?\\n$/.test( separator )  //true///\\r?\\n/.test( separator )\n\t\t\t});\n\n\t\t\ttrailingNewline = source.content.lastChar() === '\\n';\n\t\t});\n\n\t\tif (this.intro) {\n\t\t\tthis.intro =\n\t\t\t\tindentStr +\n\t\t\t\tthis.intro.replace(/^[^\\n]/gm, (match, index) => {\n\t\t\t\t\treturn index > 0 ? indentStr + match : match;\n\t\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprepend(str) {\n\t\tthis.intro = str + this.intro;\n\t\treturn this;\n\t}\n\n\ttoString() {\n\t\tconst body = this.sources\n\t\t\t.map((source, i) => {\n\t\t\t\tconst separator = source.separator !== undefined ? source.separator : this.separator;\n\t\t\t\tconst str = (i > 0 ? separator : '') + source.content.toString();\n\n\t\t\t\treturn str;\n\t\t\t})\n\t\t\t.join('');\n\n\t\treturn this.intro + body;\n\t}\n\n\tisEmpty() {\n\t\tif (this.intro.length && this.intro.trim()) return false;\n\t\tif (this.sources.some((source) => !source.content.isEmpty())) return false;\n\t\treturn true;\n\t}\n\n\tlength() {\n\t\treturn this.sources.reduce(\n\t\t\t(length, source) => length + source.content.length(),\n\t\t\tthis.intro.length,\n\t\t);\n\t}\n\n\ttrimLines() {\n\t\treturn this.trim('[\\\\r\\\\n]');\n\t}\n\n\ttrim(charType) {\n\t\treturn this.trimStart(charType).trimEnd(charType);\n\t}\n\n\ttrimStart(charType) {\n\t\tconst rx = new RegExp('^' + (charType || '\\\\s') + '+');\n\t\tthis.intro = this.intro.replace(rx, '');\n\n\t\tif (!this.intro) {\n\t\t\tlet source;\n\t\t\tlet i = 0;\n\n\t\t\tdo {\n\t\t\t\tsource = this.sources[i++];\n\t\t\t\tif (!source) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} while (!source.content.trimStartAborted(charType));\n\t\t}\n\n\t\treturn this;\n\t}\n\n\ttrimEnd(charType) {\n\t\tconst rx = new RegExp((charType || '\\\\s') + '+$');\n\n\t\tlet source;\n\t\tlet i = this.sources.length - 1;\n\n\t\tdo {\n\t\t\tsource = this.sources[i--];\n\t\t\tif (!source) {\n\t\t\t\tthis.intro = this.intro.replace(rx, '');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} while (!source.content.trimEndAborted(charType));\n\n\t\treturn this;\n\t}\n}\n", "import { isString, escapeRegExp } from '@unocss/core';\nimport MagicString from 'magic-string';\n\nfunction getBracket(str, open, close) {\n  if (str === \"\")\n    return;\n  const l = str.length;\n  let parenthesis = 0;\n  let opened = false;\n  let openAt = 0;\n  for (let i = 0; i < l; i++) {\n    switch (str[i]) {\n      case open:\n        if (!opened) {\n          opened = true;\n          openAt = i;\n        }\n        parenthesis++;\n        break;\n      case close:\n        --parenthesis;\n        if (parenthesis < 0)\n          return;\n        if (parenthesis === 0) {\n          return [\n            str.slice(openAt, i + 1),\n            str.slice(i + 1),\n            str.slice(0, openAt)\n          ];\n        }\n        break;\n    }\n  }\n}\nfunction getStringComponent(str, open, close, separators) {\n  if (str === \"\")\n    return;\n  if (isString(separators))\n    separators = [separators];\n  if (separators.length === 0)\n    return;\n  const l = str.length;\n  let parenthesis = 0;\n  for (let i = 0; i < l; i++) {\n    switch (str[i]) {\n      case open:\n        parenthesis++;\n        break;\n      case close:\n        if (--parenthesis < 0)\n          return;\n        break;\n      default:\n        for (const separator of separators) {\n          const separatorLength = separator.length;\n          if (separatorLength && separator === str.slice(i, i + separatorLength) && parenthesis === 0) {\n            if (i === 0 || i === l - separatorLength)\n              return;\n            return [\n              str.slice(0, i),\n              str.slice(i + separatorLength)\n            ];\n          }\n        }\n    }\n  }\n  return [\n    str,\n    \"\"\n  ];\n}\nfunction getStringComponents(str, separators, limit) {\n  limit = limit ?? 10;\n  const components = [];\n  let i = 0;\n  while (str !== \"\") {\n    if (++i > limit)\n      return;\n    const componentPair = getStringComponent(str, \"(\", \")\", separators);\n    if (!componentPair)\n      return;\n    const [component, rest] = componentPair;\n    components.push(component);\n    str = rest;\n  }\n  if (components.length > 0)\n    return components;\n}\n\nconst cssColorFunctions = [\"hsl\", \"hsla\", \"hwb\", \"lab\", \"lch\", \"oklab\", \"oklch\", \"rgb\", \"rgba\"];\nconst alphaPlaceholders = [\"%alpha\", \"<alpha-value>\"];\nconst alphaPlaceholdersRE = new RegExp(alphaPlaceholders.map((v) => escapeRegExp(v)).join(\"|\"));\nfunction hex2rgba(hex = \"\") {\n  const color = parseHexColor(hex);\n  if (color != null) {\n    const { components, alpha } = color;\n    if (alpha == null)\n      return components;\n    return [...components, alpha];\n  }\n}\nfunction parseCssColor(str = \"\") {\n  const color = parseColor(str);\n  if (color == null || color === false)\n    return;\n  const { type: casedType, components, alpha } = color;\n  const type = casedType.toLowerCase();\n  if (components.length === 0)\n    return;\n  if (cssColorFunctions.includes(type) && ![1, 3].includes(components.length))\n    return;\n  return {\n    type,\n    components: components.map((c) => typeof c === \"string\" ? c.trim() : c),\n    alpha: typeof alpha === \"string\" ? alpha.trim() : alpha\n  };\n}\nfunction colorOpacityToString(color) {\n  const alpha = color.alpha ?? 1;\n  return typeof alpha === \"string\" && alphaPlaceholders.includes(alpha) ? 1 : alpha;\n}\nfunction colorToString(color, alphaOverride) {\n  if (typeof color === \"string\")\n    return color.replace(alphaPlaceholdersRE, `${alphaOverride ?? 1}`);\n  const { components } = color;\n  let { alpha, type } = color;\n  alpha = alphaOverride ?? alpha;\n  type = type.toLowerCase();\n  if ([\"hsla\", \"rgba\"].includes(type))\n    return `${type}(${components.join(\", \")}${alpha == null ? \"\" : `, ${alpha}`})`;\n  alpha = alpha == null ? \"\" : ` / ${alpha}`;\n  if (cssColorFunctions.includes(type))\n    return `${type}(${components.join(\" \")}${alpha})`;\n  return `color(${type} ${components.join(\" \")}${alpha})`;\n}\nfunction parseColor(str) {\n  if (!str)\n    return;\n  let color = parseHexColor(str);\n  if (color != null)\n    return color;\n  color = cssColorKeyword(str);\n  if (color != null)\n    return color;\n  color = parseCssCommaColorFunction(str);\n  if (color != null)\n    return color;\n  color = parseCssSpaceColorFunction(str);\n  if (color != null)\n    return color;\n  color = parseCssColorFunction(str);\n  if (color != null)\n    return color;\n}\nfunction parseHexColor(str) {\n  const [, body] = str.match(/^#([\\da-f]+)$/i) || [];\n  if (!body)\n    return;\n  switch (body.length) {\n    case 3:\n    case 4:\n      const digits = Array.from(body, (s) => Number.parseInt(s, 16)).map((n) => n << 4 | n);\n      return {\n        type: \"rgb\",\n        components: digits.slice(0, 3),\n        alpha: body.length === 3 ? void 0 : Math.round(digits[3] / 255 * 100) / 100\n      };\n    case 6:\n    case 8:\n      const value = Number.parseInt(body, 16);\n      return {\n        type: \"rgb\",\n        components: body.length === 6 ? [value >> 16 & 255, value >> 8 & 255, value & 255] : [value >> 24 & 255, value >> 16 & 255, value >> 8 & 255],\n        alpha: body.length === 6 ? void 0 : Math.round((value & 255) / 255 * 100) / 100\n      };\n  }\n}\nfunction cssColorKeyword(str) {\n  const color = {\n    rebeccapurple: [102, 51, 153, 1]\n  }[str];\n  if (color != null) {\n    return {\n      type: \"rgb\",\n      components: color.slice(0, 3),\n      alpha: color[3]\n    };\n  }\n}\nfunction parseCssCommaColorFunction(color) {\n  const match = color.match(/^(rgb|rgba|hsl|hsla)\\((.+)\\)$/i);\n  if (!match)\n    return;\n  const [, type, componentString] = match;\n  const components = getStringComponents(componentString, \",\", 5);\n  if (components) {\n    if ([3, 4].includes(components.length)) {\n      return {\n        type,\n        components: components.slice(0, 3),\n        alpha: components[3]\n      };\n    } else if (components.length !== 1) {\n      return false;\n    }\n  }\n}\nconst cssColorFunctionsRe = new RegExp(`^(${cssColorFunctions.join(\"|\")})\\\\((.+)\\\\)$`, \"i\");\nfunction parseCssSpaceColorFunction(color) {\n  const match = color.match(cssColorFunctionsRe);\n  if (!match)\n    return;\n  const [, fn, componentString] = match;\n  const parsed = parseCssSpaceColorValues(`${fn} ${componentString}`);\n  if (parsed) {\n    const { alpha, components: [type, ...components] } = parsed;\n    return {\n      type,\n      components,\n      alpha\n    };\n  }\n}\nfunction parseCssColorFunction(color) {\n  const match = color.match(/^color\\((.+)\\)$/);\n  if (!match)\n    return;\n  const parsed = parseCssSpaceColorValues(match[1]);\n  if (parsed) {\n    const { alpha, components: [type, ...components] } = parsed;\n    return {\n      type,\n      components,\n      alpha\n    };\n  }\n}\nfunction parseCssSpaceColorValues(componentString) {\n  const components = getStringComponents(componentString, \" \");\n  if (!components)\n    return;\n  let totalComponents = components.length;\n  if (components[totalComponents - 2] === \"/\") {\n    return {\n      components: components.slice(0, totalComponents - 2),\n      alpha: components[totalComponents - 1]\n    };\n  }\n  if (components[totalComponents - 2] != null && (components[totalComponents - 2].endsWith(\"/\") || components[totalComponents - 1].startsWith(\"/\"))) {\n    const removed = components.splice(totalComponents - 2);\n    components.push(removed.join(\" \"));\n    --totalComponents;\n  }\n  const withAlpha = getStringComponents(components[totalComponents - 1], \"/\", 2);\n  if (!withAlpha)\n    return;\n  if (withAlpha.length === 1 || withAlpha[withAlpha.length - 1] === \"\")\n    return { components };\n  const alpha = withAlpha.pop();\n  components[totalComponents - 1] = withAlpha.join(\"/\");\n  return {\n    components,\n    alpha\n  };\n}\n\nfunction createValueHandler(handlers) {\n  const handler = function(str) {\n    const s = this.__options?.sequence || [];\n    this.__options.sequence = [];\n    for (const n of s) {\n      const res = handlers[n](str);\n      if (res != null)\n        return res;\n    }\n  };\n  function addProcessor(that, name) {\n    if (!that.__options) {\n      that.__options = {\n        sequence: []\n      };\n    }\n    that.__options.sequence.push(name);\n    return that;\n  }\n  for (const name of Object.keys(handlers)) {\n    Object.defineProperty(handler, name, {\n      enumerable: true,\n      get() {\n        return addProcessor(this, name);\n      }\n    });\n  }\n  return handler;\n}\n\nfunction variantMatcher(name, handler) {\n  let re;\n  return {\n    name,\n    match(input, ctx) {\n      if (!re)\n        re = new RegExp(`^${escapeRegExp(name)}(?:${ctx.generator.config.separators.join(\"|\")})`);\n      const match = input.match(re);\n      if (match) {\n        return {\n          matcher: input.slice(match[0].length),\n          handle: (input2, next) => next({\n            ...input2,\n            ...handler(input2)\n          })\n        };\n      }\n    },\n    autocomplete: `${name}:`\n  };\n}\nfunction variantParentMatcher(name, parent) {\n  let re;\n  return {\n    name,\n    match(input, ctx) {\n      if (!re)\n        re = new RegExp(`^${escapeRegExp(name)}(?:${ctx.generator.config.separators.join(\"|\")})`);\n      const match = input.match(re);\n      if (match) {\n        return {\n          matcher: input.slice(match[0].length),\n          handle: (input2, next) => next({\n            ...input2,\n            parent: `${input2.parent ? `${input2.parent} $$ ` : \"\"}${parent}`\n          })\n        };\n      }\n    },\n    autocomplete: `${name}:`\n  };\n}\nfunction variantGetBracket(prefix, matcher, separators) {\n  if (matcher.startsWith(`${prefix}[`)) {\n    const [match, rest] = getBracket(matcher.slice(prefix.length), \"[\", \"]\") ?? [];\n    if (match && rest) {\n      for (const separator of separators) {\n        if (rest.startsWith(separator))\n          return [match, rest.slice(separator.length), separator];\n      }\n      return [match, rest, \"\"];\n    }\n  }\n}\nfunction variantGetParameter(prefix, matcher, separators) {\n  if (matcher.startsWith(prefix)) {\n    const body = variantGetBracket(prefix, matcher, separators);\n    if (body) {\n      const [label = \"\", rest = body[1]] = variantGetParameter(\"/\", body[1], separators) ?? [];\n      return [body[0], rest, label];\n    }\n    for (const separator of separators.filter((x) => x !== \"/\")) {\n      const pos = matcher.indexOf(separator, prefix.length);\n      if (pos !== -1) {\n        const labelPos = matcher.indexOf(\"/\", prefix.length);\n        const unlabelled = labelPos === -1 || pos <= labelPos;\n        return [\n          matcher.slice(prefix.length, unlabelled ? pos : labelPos),\n          matcher.slice(pos + separator.length),\n          unlabelled ? \"\" : matcher.slice(labelPos + 1, pos)\n        ];\n      }\n    }\n  }\n}\n\nconst themeFnRE = /theme\\(\\s*['\"]?(.*?)['\"]?\\s*\\)/g;\nfunction hasThemeFn(str) {\n  return str.includes(\"theme(\") && str.includes(\")\");\n}\nfunction transformThemeFn(code, theme, throwOnMissing = true) {\n  const matches = Array.from(code.toString().matchAll(themeFnRE));\n  if (!matches.length)\n    return code;\n  const s = new MagicString(code);\n  for (const match of matches) {\n    const rawArg = match[1];\n    if (!rawArg)\n      throw new Error(\"theme() expect exact one argument, but got 0\");\n    const [rawKey, alpha] = rawArg.split(\"/\");\n    const keys = rawKey.trim().split(\".\");\n    let value = keys.reduce((t, k) => t?.[k], theme);\n    if (typeof value === \"string\") {\n      if (alpha) {\n        const color = parseCssColor(value);\n        if (color)\n          value = colorToString(color, alpha);\n      }\n      s.overwrite(\n        match.index,\n        match.index + match[0].length,\n        value\n      );\n    } else if (throwOnMissing) {\n      throw new Error(`theme of \"${rawArg}\" did not found`);\n    }\n  }\n  return s.toString();\n}\n\nexport { colorOpacityToString, colorToString, createValueHandler, getBracket, getStringComponent, getStringComponents, hasThemeFn, hex2rgba, parseCssColor, themeFnRE, transformThemeFn, variantGetBracket, variantGetParameter, variantMatcher, variantParentMatcher };\n", "import { escapeSelector, toArray } from '@unocss/core';\nimport { createValueHandler, getStringComponent, parseCssColor, colorToString, colorOpacityToString, getStringComponents } from '@unocss/rule-utils';\n\nconst directionMap = {\n  \"l\": [\"-left\"],\n  \"r\": [\"-right\"],\n  \"t\": [\"-top\"],\n  \"b\": [\"-bottom\"],\n  \"s\": [\"-inline-start\"],\n  \"e\": [\"-inline-end\"],\n  \"x\": [\"-left\", \"-right\"],\n  \"y\": [\"-top\", \"-bottom\"],\n  \"\": [\"\"],\n  \"bs\": [\"-block-start\"],\n  \"be\": [\"-block-end\"],\n  \"is\": [\"-inline-start\"],\n  \"ie\": [\"-inline-end\"],\n  \"block\": [\"-block-start\", \"-block-end\"],\n  \"inline\": [\"-inline-start\", \"-inline-end\"]\n};\nconst insetMap = {\n  ...directionMap,\n  s: [\"-inset-inline-start\"],\n  start: [\"-inset-inline-start\"],\n  e: [\"-inset-inline-end\"],\n  end: [\"-inset-inline-end\"],\n  bs: [\"-inset-block-start\"],\n  be: [\"-inset-block-end\"],\n  is: [\"-inset-inline-start\"],\n  ie: [\"-inset-inline-end\"],\n  block: [\"-inset-block-start\", \"-inset-block-end\"],\n  inline: [\"-inset-inline-start\", \"-inset-inline-end\"]\n};\nconst cornerMap = {\n  \"l\": [\"-top-left\", \"-bottom-left\"],\n  \"r\": [\"-top-right\", \"-bottom-right\"],\n  \"t\": [\"-top-left\", \"-top-right\"],\n  \"b\": [\"-bottom-left\", \"-bottom-right\"],\n  \"tl\": [\"-top-left\"],\n  \"lt\": [\"-top-left\"],\n  \"tr\": [\"-top-right\"],\n  \"rt\": [\"-top-right\"],\n  \"bl\": [\"-bottom-left\"],\n  \"lb\": [\"-bottom-left\"],\n  \"br\": [\"-bottom-right\"],\n  \"rb\": [\"-bottom-right\"],\n  \"\": [\"\"],\n  \"bs\": [\"-start-start\", \"-start-end\"],\n  \"be\": [\"-end-start\", \"-end-end\"],\n  \"s\": [\"-end-start\", \"-start-start\"],\n  \"is\": [\"-end-start\", \"-start-start\"],\n  \"e\": [\"-start-end\", \"-end-end\"],\n  \"ie\": [\"-start-end\", \"-end-end\"],\n  \"ss\": [\"-start-start\"],\n  \"bs-is\": [\"-start-start\"],\n  \"is-bs\": [\"-start-start\"],\n  \"se\": [\"-start-end\"],\n  \"bs-ie\": [\"-start-end\"],\n  \"ie-bs\": [\"-start-end\"],\n  \"es\": [\"-end-start\"],\n  \"be-is\": [\"-end-start\"],\n  \"is-be\": [\"-end-start\"],\n  \"ee\": [\"-end-end\"],\n  \"be-ie\": [\"-end-end\"],\n  \"ie-be\": [\"-end-end\"]\n};\nconst xyzMap = {\n  \"x\": [\"-x\"],\n  \"y\": [\"-y\"],\n  \"z\": [\"-z\"],\n  \"\": [\"-x\", \"-y\"]\n};\nconst xyzArray = [\"x\", \"y\", \"z\"];\nconst basePositionMap = [\n  \"top\",\n  \"top center\",\n  \"top left\",\n  \"top right\",\n  \"bottom\",\n  \"bottom center\",\n  \"bottom left\",\n  \"bottom right\",\n  \"left\",\n  \"left center\",\n  \"left top\",\n  \"left bottom\",\n  \"right\",\n  \"right center\",\n  \"right top\",\n  \"right bottom\",\n  \"center\",\n  \"center top\",\n  \"center bottom\",\n  \"center left\",\n  \"center right\",\n  \"center center\"\n];\nconst positionMap = Object.assign(\n  {},\n  ...basePositionMap.map((p) => ({ [p.replace(/ /, \"-\")]: p })),\n  ...basePositionMap.map((p) => ({ [p.replace(/\\b(\\w)\\w+/g, \"$1\").replace(/ /, \"\")]: p }))\n);\nconst globalKeywords = [\n  \"inherit\",\n  \"initial\",\n  \"revert\",\n  \"revert-layer\",\n  \"unset\"\n];\nconst cssMathFnRE = /^(calc|clamp|min|max)\\s*\\((.+)\\)(.*)/;\n\nconst numberWithUnitRE = /^(-?\\d*(?:\\.\\d+)?)(px|pt|pc|%|r?(?:em|ex|lh|cap|ch|ic)|(?:[sld]?v|cq)(?:[whib]|min|max)|in|cm|mm|rpx)?$/i;\nconst numberRE = /^(-?\\d*(?:\\.\\d+)?)$/i;\nconst unitOnlyRE = /^(px|[sld]?v[wh])$/i;\nconst unitOnlyMap = {\n  px: 1,\n  vw: 100,\n  vh: 100,\n  svw: 100,\n  svh: 100,\n  dvw: 100,\n  dvh: 100,\n  lvh: 100,\n  lvw: 100\n};\nconst bracketTypeRe = /^\\[(color|length|size|position|quoted|string):/i;\nconst splitComma = /,(?![^()]*\\))/g;\n\nconst cssProps = [\n  // basic props\n  \"color\",\n  \"border-color\",\n  \"background-color\",\n  \"flex-grow\",\n  \"flex\",\n  \"flex-shrink\",\n  \"caret-color\",\n  \"font\",\n  \"gap\",\n  \"opacity\",\n  \"visibility\",\n  \"z-index\",\n  \"font-weight\",\n  \"zoom\",\n  \"text-shadow\",\n  \"transform\",\n  \"box-shadow\",\n  // positions\n  \"background-position\",\n  \"left\",\n  \"right\",\n  \"top\",\n  \"bottom\",\n  \"object-position\",\n  // sizes\n  \"max-height\",\n  \"min-height\",\n  \"max-width\",\n  \"min-width\",\n  \"height\",\n  \"width\",\n  \"border-width\",\n  \"margin\",\n  \"padding\",\n  \"outline-width\",\n  \"outline-offset\",\n  \"font-size\",\n  \"line-height\",\n  \"text-indent\",\n  \"vertical-align\",\n  \"border-spacing\",\n  \"letter-spacing\",\n  \"word-spacing\",\n  // enhances\n  \"stroke\",\n  \"filter\",\n  \"backdrop-filter\",\n  \"fill\",\n  \"mask\",\n  \"mask-size\",\n  \"mask-border\",\n  \"clip-path\",\n  \"clip\",\n  \"border-radius\"\n];\nfunction round(n) {\n  return n.toFixed(10).replace(/\\.0+$/, \"\").replace(/(\\.\\d+?)0+$/, \"$1\");\n}\nfunction numberWithUnit(str) {\n  const match = str.match(numberWithUnitRE);\n  if (!match)\n    return;\n  const [, n, unit] = match;\n  const num = Number.parseFloat(n);\n  if (unit && !Number.isNaN(num))\n    return `${round(num)}${unit}`;\n}\nfunction auto(str) {\n  if (str === \"auto\" || str === \"a\")\n    return \"auto\";\n}\nfunction rem(str) {\n  if (!str)\n    return;\n  if (unitOnlyRE.test(str))\n    return `${unitOnlyMap[str]}${str}`;\n  const match = str.match(numberWithUnitRE);\n  if (!match)\n    return;\n  const [, n, unit] = match;\n  const num = Number.parseFloat(n);\n  if (!Number.isNaN(num)) {\n    if (num === 0)\n      return \"0\";\n    return unit ? `${round(num)}${unit}` : `${round(num / 4)}rem`;\n  }\n}\nfunction px(str) {\n  if (unitOnlyRE.test(str))\n    return `${unitOnlyMap[str]}${str}`;\n  const match = str.match(numberWithUnitRE);\n  if (!match)\n    return;\n  const [, n, unit] = match;\n  const num = Number.parseFloat(n);\n  if (!Number.isNaN(num))\n    return unit ? `${round(num)}${unit}` : `${round(num)}px`;\n}\nfunction number(str) {\n  if (!numberRE.test(str))\n    return;\n  const num = Number.parseFloat(str);\n  if (!Number.isNaN(num))\n    return round(num);\n}\nfunction percent(str) {\n  if (str.endsWith(\"%\"))\n    str = str.slice(0, -1);\n  if (!numberRE.test(str))\n    return;\n  const num = Number.parseFloat(str);\n  if (!Number.isNaN(num))\n    return `${round(num / 100)}`;\n}\nfunction fraction(str) {\n  if (!str)\n    return;\n  if (str === \"full\")\n    return \"100%\";\n  const [left, right] = str.split(\"/\");\n  const num = Number.parseFloat(left) / Number.parseFloat(right);\n  if (!Number.isNaN(num)) {\n    if (num === 0)\n      return \"0\";\n    return `${round(num * 100)}%`;\n  }\n}\nfunction bracketWithType(str, requiredType) {\n  if (str && str.startsWith(\"[\") && str.endsWith(\"]\")) {\n    let base;\n    let hintedType;\n    const match = str.match(bracketTypeRe);\n    if (!match) {\n      base = str.slice(1, -1);\n    } else {\n      if (!requiredType)\n        hintedType = match[1];\n      base = str.slice(match[0].length, -1);\n    }\n    if (!base)\n      return;\n    if (base === '=\"\"')\n      return;\n    if (base.startsWith(\"--\"))\n      base = `var(${base})`;\n    let curly = 0;\n    for (const i of base) {\n      if (i === \"[\") {\n        curly += 1;\n      } else if (i === \"]\") {\n        curly -= 1;\n        if (curly < 0)\n          return;\n      }\n    }\n    if (curly)\n      return;\n    switch (hintedType) {\n      case \"string\":\n        return base.replace(/(^|[^\\\\])_/g, \"$1 \").replace(/\\\\_/g, \"_\");\n      case \"quoted\":\n        return base.replace(/(^|[^\\\\])_/g, \"$1 \").replace(/\\\\_/g, \"_\").replace(/([\"\\\\])/g, \"\\\\$1\").replace(/^(.+)$/, '\"$1\"');\n    }\n    return base.replace(/(url\\(.*?\\))/g, (v) => v.replace(/_/g, \"\\\\_\")).replace(/(^|[^\\\\])_/g, \"$1 \").replace(/\\\\_/g, \"_\").replace(/(?:calc|clamp|max|min)\\((.*)/g, (match2) => {\n      const vars = [];\n      return match2.replace(/var\\((--.+?)[,)]/g, (match3, g1) => {\n        vars.push(g1);\n        return match3.replace(g1, \"--un-calc\");\n      }).replace(/(-?\\d*\\.?\\d(?!\\b-\\d.+[,)](?![^+\\-/*])\\D)(?:%|[a-z]+)?|\\))([+\\-/*])/g, \"$1 $2 \").replace(/--un-calc/g, () => vars.shift());\n    });\n  }\n}\nfunction bracket(str) {\n  return bracketWithType(str);\n}\nfunction bracketOfColor(str) {\n  return bracketWithType(str, \"color\");\n}\nfunction bracketOfLength(str) {\n  return bracketWithType(str, \"length\");\n}\nfunction bracketOfPosition(str) {\n  return bracketWithType(str, \"position\");\n}\nfunction cssvar(str) {\n  if (/^\\$[^\\s'\"`;{}]/.test(str)) {\n    const [name, defaultValue] = str.slice(1).split(\",\");\n    return `var(--${escapeSelector(name)}${defaultValue ? `, ${defaultValue}` : \"\"})`;\n  }\n}\nfunction time(str) {\n  const match = str.match(/^(-?[0-9.]+)(s|ms)?$/i);\n  if (!match)\n    return;\n  const [, n, unit] = match;\n  const num = Number.parseFloat(n);\n  if (!Number.isNaN(num)) {\n    if (num === 0 && !unit)\n      return \"0s\";\n    return unit ? `${round(num)}${unit}` : `${round(num)}ms`;\n  }\n}\nfunction degree(str) {\n  const match = str.match(/^(-?[0-9.]+)(deg|rad|grad|turn)?$/i);\n  if (!match)\n    return;\n  const [, n, unit] = match;\n  const num = Number.parseFloat(n);\n  if (!Number.isNaN(num)) {\n    if (num === 0)\n      return \"0\";\n    return unit ? `${round(num)}${unit}` : `${round(num)}deg`;\n  }\n}\nfunction global(str) {\n  if (globalKeywords.includes(str))\n    return str;\n}\nfunction properties(str) {\n  if (str.split(\",\").every((prop) => cssProps.includes(prop)))\n    return str;\n}\nfunction position(str) {\n  if ([\"top\", \"left\", \"right\", \"bottom\", \"center\"].includes(str))\n    return str;\n}\n\nconst valueHandlers = {\n  __proto__: null,\n  auto: auto,\n  bracket: bracket,\n  bracketOfColor: bracketOfColor,\n  bracketOfLength: bracketOfLength,\n  bracketOfPosition: bracketOfPosition,\n  cssvar: cssvar,\n  degree: degree,\n  fraction: fraction,\n  global: global,\n  number: number,\n  numberWithUnit: numberWithUnit,\n  percent: percent,\n  position: position,\n  properties: properties,\n  px: px,\n  rem: rem,\n  time: time\n};\n\nconst handler = createValueHandler(valueHandlers);\nconst h = handler;\n\nconst CONTROL_MINI_NO_NEGATIVE = \"$$mini-no-negative\";\nfunction directionSize(propertyPrefix) {\n  return ([_, direction, size], { theme }) => {\n    const v = theme.spacing?.[size || \"DEFAULT\"] ?? h.bracket.cssvar.global.auto.fraction.rem(size);\n    if (v != null)\n      return directionMap[direction].map((i) => [`${propertyPrefix}${i}`, v]);\n  };\n}\nfunction getThemeColorForKey(theme, colors, key = \"colors\") {\n  let obj = theme[key];\n  let index = -1;\n  for (const c of colors) {\n    index += 1;\n    if (obj && typeof obj !== \"string\") {\n      const camel = colors.slice(index).join(\"-\").replace(/(-[a-z])/g, (n) => n.slice(1).toUpperCase());\n      if (obj[camel])\n        return obj[camel];\n      if (obj[c]) {\n        obj = obj[c];\n        continue;\n      }\n    }\n    return void 0;\n  }\n  return obj;\n}\nfunction getThemeColor(theme, colors, key) {\n  return getThemeColorForKey(theme, colors, key) || getThemeColorForKey(theme, colors, \"colors\");\n}\nfunction splitShorthand(body, type) {\n  const [front, rest] = getStringComponent(body, \"[\", \"]\", [\"/\", \":\"]) ?? [];\n  if (front != null) {\n    const match = (front.match(bracketTypeRe) ?? [])[1];\n    if (match == null || match === type)\n      return [front, rest];\n  }\n}\nfunction parseColor(body, theme, key) {\n  const split = splitShorthand(body, \"color\");\n  if (!split)\n    return;\n  const [main, opacity] = split;\n  const colors = main.replace(/([a-z])([0-9])/g, \"$1-$2\").split(/-/g);\n  const [name] = colors;\n  if (!name)\n    return;\n  let color;\n  const bracket = h.bracketOfColor(main);\n  const bracketOrMain = bracket || main;\n  if (h.numberWithUnit(bracketOrMain))\n    return;\n  if (/^#[\\da-fA-F]+$/.test(bracketOrMain))\n    color = bracketOrMain;\n  else if (/^hex-[\\da-fA-F]+$/.test(bracketOrMain))\n    color = `#${bracketOrMain.slice(4)}`;\n  else if (main.startsWith(\"$\"))\n    color = h.cssvar(main);\n  color = color || bracket;\n  if (!color) {\n    const colorData = getThemeColor(theme, [main], key);\n    if (typeof colorData === \"string\")\n      color = colorData;\n  }\n  let no = \"DEFAULT\";\n  if (!color) {\n    let colorData;\n    const [scale] = colors.slice(-1);\n    if (/^\\d+$/.test(scale)) {\n      no = scale;\n      colorData = getThemeColor(theme, colors.slice(0, -1), key);\n      if (!colorData || typeof colorData === \"string\")\n        color = void 0;\n      else\n        color = colorData[no];\n    } else {\n      colorData = getThemeColor(theme, colors, key);\n      if (!colorData && colors.length <= 2) {\n        [, no = no] = colors;\n        colorData = getThemeColor(theme, [name], key);\n      }\n      if (typeof colorData === \"string\")\n        color = colorData;\n      else if (no && colorData)\n        color = colorData[no];\n    }\n  }\n  return {\n    opacity,\n    name,\n    no,\n    color,\n    cssColor: parseCssColor(color),\n    alpha: h.bracket.cssvar.percent(opacity ?? \"\")\n  };\n}\nfunction colorResolver(property, varName, key, shouldPass) {\n  return ([, body], { theme }) => {\n    const data = parseColor(body, theme, key);\n    if (!data)\n      return;\n    const { alpha, color, cssColor } = data;\n    const css = {};\n    if (cssColor) {\n      if (alpha != null) {\n        css[property] = colorToString(cssColor, alpha);\n      } else {\n        const opacityVar = `--un-${varName}-opacity`;\n        const result = colorToString(cssColor, `var(${opacityVar})`);\n        if (result.includes(opacityVar))\n          css[opacityVar] = colorOpacityToString(cssColor);\n        css[property] = result;\n      }\n    } else if (color) {\n      if (alpha != null) {\n        css[property] = colorToString(color, alpha);\n      } else {\n        const opacityVar = `--un-${varName}-opacity`;\n        const result = colorToString(color, `var(${opacityVar})`);\n        if (result.includes(opacityVar))\n          css[opacityVar] = 1;\n        css[property] = result;\n      }\n    }\n    if (shouldPass?.(css) !== false)\n      return css;\n  };\n}\nfunction colorableShadows(shadows, colorVar) {\n  const colored = [];\n  shadows = toArray(shadows);\n  for (let i = 0; i < shadows.length; i++) {\n    const components = getStringComponents(shadows[i], \" \", 6);\n    if (!components || components.length < 3)\n      return shadows;\n    let isInset = false;\n    const pos = components.indexOf(\"inset\");\n    if (pos !== -1) {\n      components.splice(pos, 1);\n      isInset = true;\n    }\n    let colorVarValue = \"\";\n    if (parseCssColor(components.at(0))) {\n      const color = parseCssColor(components.shift());\n      if (color)\n        colorVarValue = `, ${colorToString(color)}`;\n    } else if (parseCssColor(components.at(-1))) {\n      const color = parseCssColor(components.pop());\n      if (color)\n        colorVarValue = `, ${colorToString(color)}`;\n    }\n    colored.push(`${isInset ? \"inset \" : \"\"}${components.join(\" \")} var(${colorVar}${colorVarValue})`);\n  }\n  return colored;\n}\nfunction hasParseableColor(color, theme, key) {\n  return color != null && !!parseColor(color, theme, key)?.color;\n}\nfunction resolveBreakpoints({ theme, generator }, key = \"breakpoints\") {\n  let breakpoints;\n  if (generator.userConfig && generator.userConfig.theme)\n    breakpoints = generator.userConfig.theme[key];\n  if (!breakpoints)\n    breakpoints = theme[key];\n  return breakpoints ? Object.entries(breakpoints).sort((a, b) => Number.parseInt(a[1].replace(/[a-z]+/gi, \"\")) - Number.parseInt(b[1].replace(/[a-z]+/gi, \"\"))).map(([point, size]) => ({ point, size })) : void 0;\n}\nfunction resolveVerticalBreakpoints(context) {\n  return resolveBreakpoints(context, \"verticalBreakpoints\");\n}\nfunction makeGlobalStaticRules(prefix, property) {\n  return globalKeywords.map((keyword) => [`${prefix}-${keyword}`, { [property ?? prefix]: keyword }]);\n}\nfunction isCSSMathFn(value) {\n  return value != null && cssMathFnRE.test(value);\n}\nfunction isSize(str) {\n  if (str[0] === \"[\" && str.slice(-1) === \"]\")\n    str = str.slice(1, -1);\n  return cssMathFnRE.test(str) || numberWithUnitRE.test(str);\n}\nfunction transformXYZ(d, v, name) {\n  const values = v.split(splitComma);\n  if (d || !d && values.length === 1)\n    return xyzMap[d].map((i) => [`--un-${name}${i}`, v]);\n  return values.map((v2, i) => [`--un-${name}-${xyzArray[i]}`, v2]);\n}\n\nexport { CONTROL_MINI_NO_NEGATIVE as C, xyzArray as a, cssMathFnRE as b, cornerMap as c, directionMap as d, h as e, directionSize as f, globalKeywords as g, handler as h, insetMap as i, parseColor as j, colorResolver as k, colorableShadows as l, hasParseableColor as m, resolveVerticalBreakpoints as n, makeGlobalStaticRules as o, positionMap as p, isCSSMathFn as q, resolveBreakpoints as r, splitShorthand as s, isSize as t, transformXYZ as u, valueHandlers as v, xyzMap as x };\n"],
  "mappings": "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",
  "names": ["encode", "n", "properties", "segment", "warned", "replacement", "n", "handler", "n", "parseColor", "bracket"]
}
